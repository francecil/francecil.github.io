(window.webpackJsonp=window.webpackJsonp||[]).push([[421],{1148:function(t,n,e){"use strict";e.r(n);var a=e(27),i=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_1-音视频不同步的原因"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-音视频不同步的原因"}},[t._v("#")]),t._v(" 1.音视频不同步的原因：")]),t._v(" "),n("h2",{attrs:{id:"一般是客户端的问题。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一般是客户端的问题。"}},[t._v("#")]),t._v(" "),n("strong",[t._v("一般")]),t._v("是客户端的问题。")]),t._v(" "),n("p",[t._v("由于音视频包都会带上时间戳，出现不同步的根本原因是客户端取出当前数据包解码放入缓冲队列，进行渲染时***(在这做同步)"),n("em",[n("strong",[t._v("不能从缓冲队列中同时找到")]),t._v("当前时间戳")]),t._v("*的视频解码数据和音频解码数据，所以只能先取其中一个拿个渲染。")]),t._v(" "),n("p",[t._v("(注：拿去渲染后，如果时间戳同步，渲染一般不会出现不同步的情况，硬件处理相对成熟)；")]),t._v(" "),n("p",[t._v("渲染不同步，可以说是缓冲队列设置太小，没有考虑网络不好数据包传输慢或者需要丢包重传的情况。\n当然还有可能是解码的问题，音视频其中之一的解码效率太慢，而缓冲队列设置合适，稍微不好一点的网络情况导致解码数据包(音频or视频)来不及放入缓冲队列。")]),t._v(" "),n("h2",{attrs:{id:"如果是服务端的问题-比较不好处理。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如果是服务端的问题-比较不好处理。"}},[t._v("#")]),t._v(" 如果是服务端的问题，比较不好处理。")]),t._v(" "),n("p",[t._v("音视频线程数据采集速度不同步(和采集卡有关)，封装协议时就已经出现同一时间戳的音视频包实际是不同步的情况。")]),t._v(" "),n("h1",{attrs:{id:"_2-synchronized-实例方法与静态方法的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-synchronized-实例方法与静态方法的区别"}},[t._v("#")]),t._v(" 2. synchronized 实例方法与静态方法的区别")]),t._v(" "),n("p",[t._v("先上结论：")]),t._v(" "),n("blockquote",[n("p",[t._v("1.同一个实例，所有非静态同步方法会加锁同步，锁的对象是类实例;即先等待其中一个实例方法运行结束才能运行下一个实例方法(不管实例方法是否是同一个)")])]),t._v(" "),n("blockquote",[n("p",[t._v("2.同步实例方法的锁对象是类实例，所以不同类实例之间可以并行的运行实例方法")])]),t._v(" "),n("blockquote",[n("p",[t._v("3.同步静态方法的锁对象是Class类本身，所以静态方法间的运行是串行的")])]),t._v(" "),n("blockquote",[n("p",[t._v("4.类的静态方法和类实例的实例方法同时运行，由于锁对象不同，运行是并行的")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('public class TestSynchronized {\n\tpublic synchronized static void synstaMethod1(){\n\t\tSystem.out.println("i am synstaMethod1 start");\n\t\ttimeTask();\n\t\tSystem.out.println("i am synstaMethod1 end");\n\t}\n\n\tpublic synchronized static void synstaMethod2()  {\n\t\tSystem.out.println("i am synstaMethod2 start");\n\t\ttimeTask();\n\t\tSystem.out.println("i am synstaMethod2 end");\n\t}\n\n\tpublic synchronized void synMethod1()  {\n\t\tSystem.out.println("i am synMethod1 start");\n\t\ttimeTask();\n\t\tSystem.out.println("i am synMethod1 end");\n\t}\n\n\tpublic void synMethod2()  {\n\t\tsynchronized (this) {\n\t\t\tSystem.out.println("i am synMethod2 start");\n\t\t\ttimeTask();\n\t\t\tSystem.out.println("i am synMethod2 end");\n\t\t}\n\t}\n\n\tpublic static void timeTask() {\n\t\tdouble i = 0;\n\t\twhile (true) {\n\t\t\ti += 1;\n\t\t\tif (i > 1000000000)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpublic static void timeTask2() {\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t//下面这方法不好测试 会另开线程\n\tpublic static void timeTask3(String methodName) {\n\t\tTimer timer = new Timer();\n\t\t// 3s后运行该任务\n\t\ttimer.schedule(new TimerTask() {\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.printf("i am %s end\\n",methodName);\n\t\t\t\ttimer.cancel();\n\t\t\t}\n\t\t}, 1000);\n\t}\n}\n')])])]),n("p",[t._v("测试方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("package com.france;\n\n//话说JUnit做多线程测试有诸多不便..还是用Main来测试把..\npublic class Main {\n\tstatic TestSynchronized obj1 = new TestSynchronized();\n\tstatic TestSynchronized obj2 = new TestSynchronized();\n\n\t// 测试:同一个类实例的实例方法\n\t// 结论:同一个实例，所有非静态同步方法会加锁同步，锁的对象是类实例;即先等待其中一个实例方法运行结束才能运行下一个实例方法(不管实例方法是否是同一个)\n\t// output:\n\t// i am synMethod1 start\n\t// i am synMethod1 end\n\t// i am synMethod2 start\n\t// i am synMethod2 end\n\t// i am synMethod2 start\n\t// i am synMethod2 end\n\t@org.junit.Test\n\tpublic static void testSameObjectUnstatic() {\n\t\t// 先运行完其中的一个实例方法完再运行下一个实例方法\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tobj1.synMethod1();\n\t\t\t}\n\t\t}).start();\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tobj1.synMethod2();\n\t\t\t}\n\t\t}).start();\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tobj1.synMethod2();\n\t\t\t}\n\t\t}).start();\n\t}\n\n\t// 测试:不同类实例的实例方法\n\t// 结论:同步实例方法的锁对象是类实例，所以不同类实例之间可以并行的运行实例方法\n\t// output:\n\t// i am synMethod1 start\n\t// i am synMethod2 start\n\t// i am synMethod2 end\n\t// i am synMethod1 end\n\t@org.junit.Test\n\tpublic static void testDifferentObjectUnstatic() {\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tobj2.synMethod1();\n\t\t\t}\n\t\t}).start();\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tobj1.synMethod2();\n\t\t\t}\n\t\t}).start();\n\t}\n\n\t// 测试:类的静态方法\n\t// 结论:同步静态方法的锁对象是Class类本身，所以静态方法间的运行是串行的\n\t// 注意与该方法的调用者(Class或者类实例)无关\n\t// output:\n\t// i am synstaMethod1 start\n\t// i am synstaMethod1 end\n\t// i am synstaMethod2 start\n\t// i am synstaMethod2 end\n\t@org.junit.Test\n\tpublic static void testClassStatic() {\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tTestSynchronized.synstaMethod1();\n\t\t\t}\n\t\t}).start();\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tTestSynchronized.synstaMethod2();\n\t\t\t}\n\t\t}).start();\n\t}\n\n\t// 测试:类的静态方法和类实例的实例方法\n\t// 结论:类的静态方法和类实例的实例方法同时运行，由于锁对象不同，运行是并行的\n\t// 注意与该方法的调用者(Class或者类实例)无关\n\t// output:\n\t// i am synstaMethod1 start\n\t// i am synMethod2 start\n\t// i am synstaMethod1 end\n\t// i am synMethod2 end\n\t@org.junit.Test\n\tpublic static void testClassAndObject() {\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tTestSynchronized.synstaMethod1();\n\t\t\t}\n\t\t}).start();\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tobj1.synMethod2();\n\t\t\t}\n\t\t}).start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\ttestClassAndObject();\n\t}\n\n}\n")])])]),n("h1",{attrs:{id:"_3-android-事件分发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-android-事件分发"}},[t._v("#")]),t._v(" 3.Android 事件分发")]),t._v(" "),n("p",[t._v("参考：(荐)http://blog.csdn.net/duo2005duo/article/details/51604119\nhttp://www.jianshu.com/p/6ebdb78f579e")]),t._v(" "),n("p",[t._v("1.一次Touch有UP,MOVE（>=0次），UP/Cancel,事件至上而下传递")]),t._v(" "),n("h3",{attrs:{id:"viewgroup的dispatchtouchevent方法分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#viewgroup的dispatchtouchevent方法分析"}},[t._v("#")]),t._v(" ViewGroup的dispatchTouchEvent方法分析")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public boolean dispatchTouchEvent(MotionEvent ev) {\n    final int action = ev.getAction();\n    final float xf = ev.getX();\n    final float yf = ev.getY();\n    final float scrolledXFloat = xf + mScrollX;\n    final float scrolledYFloat = yf + mScrollY;\n    final Rect frame = mTempRect;\n\n    boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n\n    if (action == MotionEvent.ACTION_DOWN) {\n        //1.只有在非拦截的情况的下寻找target\n        if (disallowIntercept || !onInterceptTouchEvent(ev)) {\n            // 防止onInterceptTouchEvent()的时候改变Action\n            ev.setAction(MotionEvent.ACTION_DOWN);\n            // 遍历子View，第一个消费这个事件的子View的为Target\n            final int scrolledXInt = (int) scrolledXFloat;\n            final int scrolledYInt = (int) scrolledYFloat;\n            final View[] children = mChildren;\n            final int count = mChildrenCount;\n            for (int i = count - 1; i >= 0; i--) {\n                final View child = children[i];\n                //当然只遍历可见的，并且没有在进行动画的。\n                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE\n                        || child.getAnimation() != null) {\n                    child.getHitRect(frame);\n                    if (frame.contains(scrolledXInt, scrolledYInt)) {\n                        // offset the event to the view's coordinate system\n                        final float xc = scrolledXFloat - child.mLeft;\n                        final float yc = scrolledYFloat - child.mTop;\n                        ev.setLocation(xc, yc);\n                        if (child.dispatchTouchEvent(ev))  {\n                            // Event handled, we have a target now.\n                            mMotionTarget = child;\n                            return true;\n                        }\n                                            }\n                }\n            }\n        }\n    }\n\n    boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||\n            (action == MotionEvent.ACTION_CANCEL);\n    //up或者cancel的时候清空DisallowIntercept\n    if (isUpOrCancel) {\n        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n    }\n\n    // 如果没有target，则把自己当成View，向自己派发事件\n    final View target = mMotionTarget;\n    if (target == null) {\n        // We don't have a target, this means we're handling the\n        // event as a regular view.\n        ev.setLocation(xf, yf);\n        return super.dispatchTouchEvent(ev);\n    }\n\n    // 如果有Target，拦截了，则对Target发送Cancel,并且清空Target\n    if (!disallowIntercept && onInterceptTouchEvent(ev)) {\n        final float xc = scrolledXFloat - (float) target.mLeft;\n        final float yc = scrolledYFloat - (float) target.mTop;\n        ev.setAction(MotionEvent.ACTION_CANCEL);\n        ev.setLocation(xc, yc);\n        if (!target.dispatchTouchEvent(ev)) {\n            // target didn't handle ACTION_CANCEL. not much we can do\n            // but they should have.\n        }\n        // clear the target\n        mMotionTarget = null;\n        // Don't dispatch this event to our own view, because we already\n        // saw it when intercepting; we just want to give the following\n        // event to the normal onTouchEvent().\n        return true;\n    }\n    //up 或者 cancel清空Target\n    if (isUpOrCancel) {\n        mMotionTarget = null;\n    }\n\n    //如果有Target，并且没有拦截，则向Target派发事件，这个事件会转化成Target的坐标系\n    final float xc = scrolledXFloat - (float) target.mLeft;\n    final float yc = scrolledYFloat - (float) target.mTop;\n    ev.setLocation(xc, yc);\n\n    return target.dispatchTouchEvent(ev);\n}\n")])])]),n("p",[t._v("2.点击某个View控件,系统计算位置然后找到根ViewGroup;\n"),n("code",[t._v("ACTION_DOWN且ViewGroup非拦截")]),t._v("时"),n("strong",[t._v("向下分发")]),t._v("：如果ViewGroup的某个子View消费掉(View的dispatchTouchEvent返回true),则不再分发并且进行"),n("strong",[t._v("向上传递")]),t._v("：ViewGroup遍历子View，将第一个消费这个事件的子View置为Target\n3.如果"),n("strong",[t._v("ViewGroup没有target")]),t._v("，则把自己当成View，向自己派发事件："),n("code",[t._v("向下分发时没有子View消费")]),t._v("\n4.如果"),n("strong",[t._v("ViewGroup有Target，并且拦截了")]),t._v("，则对Target发送Cancel,并且清空Target。需要分析"),n("code",[t._v("onInterceptTouchEvent")]),t._v("方法\n5.如果"),n("strong",[t._v("ViewGroup有Target，并且没有拦截")]),t._v("，则向Target派发事件。比如DOWN时设置子View为Target 然后现在ACTION_MOVE,则向该子VIEW派发该事件")]),t._v(" "),n("h3",{attrs:{id:"view的dispatchtouchevent方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#view的dispatchtouchevent方法"}},[t._v("#")]),t._v(" View的dispatchTouchEvent方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public boolean dispatchTouchEvent(MotionEvent event) {\n    boolean result = false;\n    //1.停止嵌套滑动\n    final int actionMasked = event.getActionMasked();\n    if (actionMasked == MotionEvent.ACTION_DOWN) {\n        stopNestedScroll();\n    }\n    //2.安全监测\n    if (onFilterTouchEventForSecurity(event)) {\n        //noinspection SimplifiableIfStatement\n        ListenerInfo li = mListenerInfo;\n\n        //3.如果当前View使能（setEnabled(true)），则调用Touch监听器    \n        if (li != null && li.mOnTouchListener != null\n                && (mViewFlags & ENABLED_MASK) == ENABLED\n                && li.mOnTouchListener.onTouch(this, event)) {\n            result = true;\n        }\n        //4.如果Touch监听器返回false或者没有调用Touch监听器，则返回调用onTouchEvent()\n        if (!result && onTouchEvent(event)) {\n            result = true;\n        }\n    }\n    //停止嵌套滑动\n    if (actionMasked == MotionEvent.ACTION_UP ||\n            actionMasked == MotionEvent.ACTION_CANCEL ||\n            (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n        stopNestedScroll();\n    }\n\n    return result;\n}\n")])])]),n("p",[t._v("分析3.\n第一个if语句要同时满足"),n("code",[t._v("li != null 、 li.mOnTouchListener != null 、 (mViewFlags & ENABLED_MASK) == ENABLED 、 li.mOnTouchListener.onTouch(this, event)；")]),t._v("\n第一个一般不会为null，所以走第二个条件，刚刚上面说到mOnTouchListener是我们在setOnTouchListener的时候传递过来的，所以只要设置了TouchListener，这个条件也会成立；\n第三个条件是判断控件是否是enable的，一般控件默认都是enable的，除非你明确的设置成disable；\n接着判断第四个条件，就是回调mOnTouchListener的onTouch方法，这个方法是我们自己重写的，如果我们返回false，这个条件就不成立，否则我们返回true，该条件就成立，然后执行"),n("code",[t._v("result=true")]),t._v("。")]),t._v(" "),n("p",[t._v("如果第一个if不满足就会执行"),n("code",[t._v("onTouchEvent")]),t._v("方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public boolean onTouchEvent(MotionEvent event) {    \n\n...\nif (((viewFlags & CLICKABLE) == CLICKABLE ||\n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||\n            (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {\n        switch (action) {\n            case MotionEvent.ACTION_UP://抬起事件\n                //巴拉巴拉巴拉....\n                if (mPerformClick == null) {\n                    mPerformClick = new PerformClick();\n                }\n                if (!post(mPerformClick)) {\n                    performClick();//去调用onClick方法\n                }\n                ......\n                break;\n            case MotionEvent.ACTION_DOWN://按下事件\n                //巴拉巴拉巴拉....\n                break;\n            case MotionEvent.ACTION_CANCEL://取消事件\n                //巴拉巴拉巴拉....\n                break;\n            case MotionEvent.ACTION_MOVE://移动事件\n                //巴拉巴拉巴拉....\n                break;\n        }//switch语句执行完毕\n\n    return true;//如果控件可以点击，也就是说可以进入到这个if语句里面，那么总会返回true\n}//if语句结束\nreturn false;//如果控件不可以点击，就进不到上面的if语句里面，那么总会返回false\n")])])]),n("p",[t._v("}\n这个条件是判断控件是否可以支持点击事件，如果支持点击事件进入语句体，开始执行switch语句，可以看到switch执行完毕之后总是会返回true\n"),n("strong",[n("code",[t._v("onTouchEvent")]),t._v("方法总结：")]),t._v("\n1.不管View使能与否，只要clickable或者longclickable，就一定消费事件（返回true）\n2.如果View不使能，并且clickable或者longclick，就只会消费事件但不做其他任何操作\n3.如果View使能，先看看TouchDelegate消费与否，如果不消费再给自己消费\n4.处理包括focus，press，click，longclick")]),t._v(" "),n("h3",{attrs:{id:"demo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#demo"}},[t._v("#")]),t._v(" Demo:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('tv.setOnTouchListener(new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            switch (event.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    Log.i(TAG, "onTouch: ACTION_DOWN");\n                    break;\n\n                case MotionEvent.ACTION_MOVE:\n                    Log.i(TAG, "onTouch: ACTION_MOVE");\n                    break;\n\n                case MotionEvent.ACTION_UP:\n                    Log.i(TAG, "onTouch: ACTION_UP");\n                    break;\n            }\n            return false;\n        }\n    });\n\n点击TextView，log如下：\n\n06-04 04:38:46.835 15690-15690/cn.wang.permissiondemo I/ThirdActivity: onTouch: ACTION_DOWN\n')])])]),n("p",[t._v("执行流程（TextView的CLICKABLE=false）：\n1.ACTION_DOWN：ViewGroup向下分发，找到某个View尝试进行消费\n2.该View执行TouchListener.onTouch 处理了ACTION_DOWN，但是返回false，继续运行该View的onTouchEvent发现CLICKABLE是false然后方法返回false.\n3.遍历子View后，此时ViewGroup没有找到子View可以消费事件，将自己当成View进行派发事件("),n("strong",[t._v("super.dispatchTouchEvent")]),t._v("),该dispatchTouchEvent默认返回false,就这样不断向上传递\n4.ACTION_MOVE:ViewGroup没有Target,故还是自己当成View进行派发事件，并返回false\n总的说，打印了ACTION_DOWN只是一开始View进行尝试消费时运行的..")]),t._v(" "),n("h1",{attrs:{id:"_4-内存泄漏检测工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-内存泄漏检测工具"}},[t._v("#")]),t._v(" 4.内存泄漏检测工具")]),t._v(" "),n("h3",{attrs:{id:"先说下经常出现内存泄漏的几种情况及解决"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#先说下经常出现内存泄漏的几种情况及解决"}},[t._v("#")]),t._v(" 先说下经常出现内存泄漏的几种情况及解决")]),t._v(" "),n("h4",{attrs:{id:"_1-activity的context传给单例-改为传applicationcontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-activity的context传给单例-改为传applicationcontext"}},[t._v("#")]),t._v(" 1.Activity的Context传给单例->改为传ApplicationContext")]),t._v(" "),n("h4",{attrs:{id:"_2-在某个类-activity-中创建了一个非静态内部类-默认会持有外部类-activity-的引用-并且创建了该类的单例-全局静态变量-该变量在某个方法中被实例化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-在某个类-activity-中创建了一个非静态内部类-默认会持有外部类-activity-的引用-并且创建了该类的单例-全局静态变量-该变量在某个方法中被实例化"}},[t._v("#")]),t._v(" 2.在某个类(Activity)中创建了一个非静态内部类（默认会持有外部类(Activity)的引用），并且创建了该类的单例(全局静态变量)，该变量在某个方法中被实例化；")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("注：该变量生命周期与应用一致.也就是说，在应用生命周期中，该变量会持有Activity的引用导致不能进行回收\n改进->将该非静态内部类该为静态内部类或单独提出封装成一个单例\n")])])]),n("h4",{attrs:{id:"_3-通过这样创建的handler-handler-new-handler-非静态匿名内部类持有activity的引用-当activity销毁-而handler里面有消息未完全处理完时-无法正常回收activity"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-通过这样创建的handler-handler-new-handler-非静态匿名内部类持有activity的引用-当activity销毁-而handler里面有消息未完全处理完时-无法正常回收activity"}},[t._v("#")]),t._v(" 3.通过这样创建的Handler handler=new Handler(){...}非静态匿名内部类持有Activity的引用. 当Activity销毁 而Handler里面有消息未完全处理完时，无法正常回收Activity.")]),t._v(" "),n("blockquote",[n("p",[t._v("改进->覆盖Handler类被静态实现被弱引用Context,被注意移除消息队列中消息(否则虽避免Activity内存泄漏但是Handler)")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('    public class MainActivity extends AppCompatActivity {\n  private MyHandler mHandler = new MyHandler(this);\n  private TextView mTextView ;\n  private static class MyHandler extends Handler {\n    private WeakReference<Context> reference;\n    public MyHandler(Context context) {\n      reference = new WeakReference<>(context);\n    }\n    @Override\n    public void handleMessage(Message msg) {\n      MainActivity activity = (MainActivity) reference.get();\n      if(activity != null){\n        activity.mTextView.setText("");\n      }\n    }\n  }\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mTextView = (TextView)findViewById(R.id.textview);\n    loadData();\n  }\n  private void loadData() {\n    //...request\n    Message message = Message.obtain();\n    mHandler.sendMessage(message);\n  }\n  @Override\n  protected void onDestroy() {\n    super.onDestroy();\n    mHandler.removeCallbacksAndMessages(null);\n  }\n}\n')])])]),n("h4",{attrs:{id:"_4-资源未关闭造成的内存泄漏"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-资源未关闭造成的内存泄漏"}},[t._v("#")]),t._v(" 4.资源未关闭造成的内存泄漏")]),t._v(" "),n("p",[t._v("BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap,注册的系统监听器等资源的使用，应该在Activity销毁时及时关闭或者注销")]),t._v(" "),n("blockquote",[n("p",[t._v("使用完Bitmap后先调用recycle()，再赋为null")])]),t._v(" "),n("h4",{attrs:{id:"_5-线程造成的内存泄漏"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-线程造成的内存泄漏"}},[t._v("#")]),t._v(" 5.线程造成的内存泄漏")]),t._v(" "),n("p",[t._v("将异步任务和Runnable写成非静态匿名内部类，那么他们持有Activity的引用 如果Activity销毁时任务还没完成将导致Activity的资源无法正常回收")]),t._v(" "),n("blockquote",[n("p",[t._v("正确的做法还是使用静态内部类的方式")])]),t._v(" "),n("h3",{attrs:{id:"检测工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#检测工具"}},[t._v("#")]),t._v(" 检测工具")]),t._v(" "),n("p",[n("strong",[t._v("MAT")]),t._v("（比较复杂，面试的时候就提到有安装该插件 但是具体没用过）\n"),n("strong",[t._v("LeakCanary")]),t._v("(onCreate里加一句代码，然后出现泄漏会发通知，点通知跳转到具体原因的页面，面试就讲这个)\nndk内存泄漏检测工具?Valgrind， 有点复杂")]),t._v(" "),n("h1",{attrs:{id:"_5-view绘制过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-view绘制过程"}},[t._v("#")]),t._v(" 5.View绘制过程")]),t._v(" "),n("ol",[n("li",[t._v("自上而下，先设置父视图，再循环设置子视图;")]),t._v(" "),n("li",[t._v("先通过measure计算视图大小，再通过layout计算视图位置，再调用draw绘制;")]),t._v(" "),n("li",[t._v("子视图的measure由父子视图共同决定,layout方法是传入四个位置的坐标,draw时先绘制background,然后绘制当前view的内容,再遍历view;\n"),n("strong",[t._v("总过程")]),t._v(":measure(viewgroup->childview)->layout(viewgroup->childview)->draw(viewgroup->childview);")])]),t._v(" "),n("h1",{attrs:{id:"_6-android的两种广播注册方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-android的两种广播注册方式"}},[t._v("#")]),t._v(" 6.Android的两种广播注册方式")]),t._v(" "),n("p",[t._v("代码中注册，与程序生命周期有关\nManifest.XML中注册，在系统中常驻:始终处于活动状态 耗电")]),t._v(" "),n("h1",{attrs:{id:"_7-threadlocal-的用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-threadlocal-的用法"}},[t._v("#")]),t._v(" 7.ThreadLocal 的用法")]),t._v(" "),n("p",[t._v("提供线程内部的局部变量，本线程随时可取，隔离其他线程")]),t._v(" "),n("h1",{attrs:{id:"_8-java的几种引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-java的几种引用"}},[t._v("#")]),t._v(" 8.Java的几种引用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("软引用对象在内存不足会被回收;\n弱引用只要进行GC就会被回收;\n虚引用对象任何时候都会被回收(不仅是GC);\n强引用对象不会被回收，一般不用的时候需要代码显示将其置null，不然宁愿OOM也不会回收;\n")])])]),n("p",[t._v("另外讲下"),n("strong",[t._v("GC分主GC和次GC")]),t._v(",次GC比较平滑，主GC满足一定条件才会调用\n"),n("code",[t._v("System.gc()")]),t._v(":调用该方法，JVM底层建议进行主GC，大部分情况会进行非一定，增加了间接性停顿的次数..")]),t._v(" "),n("h1",{attrs:{id:"_9-android数据库升级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-android数据库升级"}},[t._v("#")]),t._v(" 9.Android数据库升级")]),t._v(" "),n("p",[t._v("传入的数据库版本比之前的大，会调用SQLiteOpenHelper#onUpgrade()方法，我们在该方法做如下操作：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1.将要修改的表A重命名为A_temp\n2.先建表A,并把A_temp的数据传入A\n3.删除A_temp\n")])])]),n("h1",{attrs:{id:"_10-handlerthread"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-handlerthread"}},[t._v("#")]),t._v(" 10.HandlerThread")]),t._v(" "),n("p",[t._v("另开线程，封装了创建Looper,Handle去处理MessageQueue的操作")]),t._v(" "),n("h1",{attrs:{id:"_11-onsaveinstancestate和onrestoreinstancestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11-onsaveinstancestate和onrestoreinstancestate"}},[t._v("#")]),t._v(" 11.onSaveInstanceState和onRestoreInstanceState")]),t._v(" "),n("h3",{attrs:{id:"onsaveinstancestate触发时机-存在非用户主动销毁activity的情况下会触发-如-按home-切换程序-转屏-进activityb-关屏幕等-系统在内存不足时会销毁activity-转屏是一定会销毁如果没设置的话"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#onsaveinstancestate触发时机-存在非用户主动销毁activity的情况下会触发-如-按home-切换程序-转屏-进activityb-关屏幕等-系统在内存不足时会销毁activity-转屏是一定会销毁如果没设置的话"}},[t._v("#")]),t._v(" onSaveInstanceState触发时机：存在非用户主动销毁Activity的情况下会触发，如：按HOME,切换程序，转屏，进ActivityB,关屏幕等，系统在内存不足时会销毁Activity（转屏是一定会销毁如果没设置的话）")]),t._v(" "),n("h3",{attrs:{id:"onrestoreinstancestate调用时机-activity确实被销毁了"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#onrestoreinstancestate调用时机-activity确实被销毁了"}},[t._v("#")]),t._v(" onRestoreInstanceState调用时机：Activity确实被销毁了")]),t._v(" "),n("h1",{attrs:{id:"_12-hashtable-hashset-hashmap-细节"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_12-hashtable-hashset-hashmap-细节"}},[t._v("#")]),t._v(" 12.Hashtable HashSet HashMap 细节")]),t._v(" "),n("p",[t._v("HashSet里面维护了一个"),n("strong",[t._v("HashMap map变量")]),t._v("，增删改查都是对map对象的key进行操作，map的key即set的value\nHashMap里面定义了静态内部类"),n("strong",[t._v("Node<K,V>"),n("strong",[t._v("和")]),t._v("transient Node<K,V>[] table")]),t._v("，K由key和hash(key)确定；非并发操作\nHashtable 维护了"),n("strong",[t._v("private transient Entry<?,?>[] table")]),t._v("，其上的操作synchronized->并发，允许null值")]),t._v(" "),n("h1",{attrs:{id:"_13-java8-concurrenthashmap源码-分段锁是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_13-java8-concurrenthashmap源码-分段锁是什么"}},[t._v("#")]),t._v(" 13.java8 ConcurrentHashMap源码 分段锁是什么")]),t._v(" "),n("p",[t._v("insert链表头是采用CAS汇编指令集判断数据一致性，每个链表头加锁\n链表>8才则tree化，桶数量>64也tree化")]),t._v(" "),n("h1",{attrs:{id:"_14-bitmap压缩"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_14-bitmap压缩"}},[t._v("#")]),t._v(" 14.bitmap压缩")]),t._v(" "),n("p",[n("code",[t._v("inJustDecodeBounds")]),t._v("设置为true 不会分配bitmap内存 但是可以获取宽高\n然后设置"),n("code",[t._v("inSampleSize")]),t._v("为我们想要的压缩比(和获取的宽高有关，取"),n("strong",[t._v("小的比例")]),t._v("？)")]),t._v(" "),n("blockquote",[n("p",[t._v("源300,200 目标100,100 一般是压缩2 变为 150，100  而不是100，67..不过这也要看应用")])]),t._v(" "),n("p",[t._v("再设置 "),n("code",[t._v("inJustDecodeBounds")]),t._v("为false 然后return "),n("code",[t._v("BitmapFactory.decodeResource(res, resId, options);")])]),t._v(" "),n("h1",{attrs:{id:"_15-android中的几种设计模式-待补充"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_15-android中的几种设计模式-待补充"}},[t._v("#")]),t._v(" 15.Android中的几种设计模式（待补充）")]),t._v(" "),n("h3",{attrs:{id:"工厂"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#工厂"}},[t._v("#")]),t._v(" 工厂")]),t._v(" "),n("p",[t._v("BitmapFactory.decodeResource.. 生产出bitmap")]),t._v(" "),n("h3",{attrs:{id:"适配器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#适配器"}},[t._v("#")]),t._v(" 适配器")]),t._v(" "),n("p",[t._v("不同的数据提供者通过同一接口提供给同一客户:Adapter")]),t._v(" "),n("h3",{attrs:{id:"创建者模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建者模式"}},[t._v("#")]),t._v(" 创建者模式")]),t._v(" "),n("p",[t._v("复杂对象的构建和表现分离")]),t._v(" "),n("h3",{attrs:{id:"抽象工厂"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂"}},[t._v("#")]),t._v(" 抽象工厂")]),t._v(" "),n("p",[t._v("MediaPlayerFactory：ijk项目的player有好几种实现，后面具体生成哪个Player就看用户选择了")]),t._v(" "),n("h3",{attrs:{id:"原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),n("p",[t._v("Bitmap.copy(Config.RGB_xxx)方法修改部分数据然后进行对象的clone\nAlertDialog.Builder")]),t._v(" "),n("h1",{attrs:{id:"_16-笔试-扔硬币正反概率都是0-5-直到连续的2次都为正面即结束-问结束次数的期望"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-笔试-扔硬币正反概率都是0-5-直到连续的2次都为正面即结束-问结束次数的期望"}},[t._v("#")]),t._v(" 16.[笔试]扔硬币正反概率都是0.5，直到连续的2次都为正面即结束，问结束次数的期望")]),t._v(" "),n("p",[t._v("解：这题如果一直穷举，列数列，找规律 难度很大，会在其中陷入循环....\n所以我们设法得到一个等式。设次数的期望为E.我们现在开始抛第一枚硬币，有以下情况：")]),t._v(" "),n("ol",[n("li",[t._v("第一枚硬币为负，那么需要重新扔，所占比例的期望为"),n("code",[t._v("0.5*（1+E）")])]),t._v(" "),n("li",[t._v("第一枚硬币为正，第二枚为负，那么需要重新扔，所占比例的期望为"),n("code",[t._v("0.25*（2+E）")])]),t._v(" "),n("li",[t._v("一正二正，结束，"),n("code",[t._v("0.25*2")])])]),t._v(" "),n("blockquote",[n("p",[t._v("得到 "),n("code",[t._v("E= 0.5*（1+E）+ 0.25*（2+E）+ 0.25*2")]),t._v(" 解得"),n("code",[t._v("E=6")])])]),t._v(" "),n("p",[t._v("也可以写代码跑下，随着样例越大答案会趋近于6")]),t._v(" "),n("h3",{attrs:{id:"改为-负正-即结束-问期望"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#改为-负正-即结束-问期望"}},[t._v("#")]),t._v(" 改为 负正 即结束 问期望")]),t._v(" "),n("p",[t._v("情况为以下，注：当出现连续的-时我们只考虑下次是否为+即可，否则说明为-我们继续判断下下次")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("+:"),n("code",[t._v("0.5*(E+1)")])])]),t._v(" "),n("li",[n("p",[t._v("-+:"),n("code",[t._v("0.25*2")])])]),t._v(" "),n("li",[n("p",[t._v("--+:"),n("code",[t._v("0.125*3")]),t._v("\n...")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("（-...-）[n个]+")]),t._v("："),n("code",[t._v("(0.5)^(n+1)*(n+1)")])]),t._v(" "),n("p",[t._v("E=0.5E+0.5+0.25"),n("em",[t._v("2+...+(0.5)^(n+1)")]),t._v("(n+1)\n高中知识：错位相减法\n0.5E=0.5"),n("em",[t._v("1+0.25")]),t._v("2+...+(0.5)^(n+1)"),n("em",[t._v("(n+1)\n0.25E=0.25")]),t._v("1+0.125"),n("em",[t._v("2+...+(0.5)^(n+2)")]),t._v("(n+1)\n两式相减：\n0.25E=0.5+0.25+0.125+...+0.5^(n+1)-(0.5)^(n+2)"),n("em",[t._v("(n+1)\n等比数列求和:0.5+0.25+0.125+...+0.5^(n+1)  a1=0.5 q=0.5\n等比数列前n项和(其实不用算也能得到是趋于1的无穷...E=4):\nSn=0.5")]),t._v("(1-0.5^n)/(1-0.5)=1-0.5^n\n故0.25E=1-0.5^n-0.5^(n+2)"),n("em",[t._v("(n+1)\nE=4")]),t._v("(1-0.5^n-0.5^(n+2)*(n+1))")])])]),t._v(" "),n("blockquote",[n("p",[n("strong",[t._v("n→∞ 得E=4")])])]),t._v(" "),n("h3",{attrs:{id:"改成-出现-甲赢-乙赢-问甲赢的概率"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#改成-出现-甲赢-乙赢-问甲赢的概率"}},[t._v("#")]),t._v(" 改成 出现+-甲赢，--乙赢，问甲赢的概率")]),t._v(" "),n("p",[t._v("只要投硬币出现+说明后面甲一定赢了，乙赢的情况必须是一开始就是--\n很容易求得甲赢的概率为0.5+0.5*0.5=0.75")]),t._v(" "),n("h3",{attrs:{id:"改成-出现-说明甲赢-出现-说明乙赢-问甲赢的概率"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#改成-出现-说明甲赢-出现-说明乙赢-问甲赢的概率"}},[t._v("#")]),t._v(" 改成 出现--+说明甲赢 出现-++说明乙赢，问甲赢的概率")]),t._v(" "),n("h4",{attrs:{id:"思路1-分别求-和-的期望"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思路1-分别求-和-的期望"}},[t._v("#")]),t._v(" ~~ 思路1：分别求--+和-++的期望 ~~")]),t._v(" "),n("p",[n("em",[n("strong",[t._v("[不可行 例：-+和--期望分别是4 6 但是两人赢的概率是一样的]")])]),t._v("\n说明两个事件是相关的，不能分别求。")]),t._v(" "),n("h4",{attrs:{id:"思路2-那么分别求不出现-情况条件下出现-的期望和不出现-情况条件下出现-的期望呢-条件概率。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思路2-那么分别求不出现-情况条件下出现-的期望和不出现-情况条件下出现-的期望呢-条件概率。"}},[t._v("#")]),t._v(" ~~ 思路2：那么分别求不出现-++情况条件下出现--+的期望和不出现--+情况条件下出现-++的期望呢，条件概率。~~")]),t._v(" "),n("h4",{attrs:{id:"思路3-直接算"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思路3-直接算"}},[t._v("#")]),t._v(" 思路3：直接算")]),t._v(" "),n("p",[t._v("顺便复习**"),n("code",[t._v("可计算理论")]),t._v("**\n求 表示不含-++且以--+结尾的-+字符串的`正则表达式\n先画DFA")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/10/3485134816.png",alt:"1"}})]),t._v(" "),n("p",[t._v("DFA转正则\n"),n("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/10/424718253.png",alt:"2.png"}})]),t._v(" "),n("p",[t._v("最后的正则表达式如下 "),n("code",[t._v("\\+*-(\\+-|--)*-\\+")])]),t._v(" "),n("p",[t._v("所以不含-++且以--+结尾的概率为\n"),n("code",[t._v("+*-")]),t._v(" ：概率为1\n"),n("code",[t._v("(\\+-|--)*-\\+")]),t._v(" ：以下概率的和")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("先找几项\n-+：0.5^2\n---+：0.5^2*0.5^2\n+--+：0.5^2*0.5^2\n-----+：0.5^4*0.5^2\n--+--+: 0.5^3 以--+-开头的不用再往后搜索了\n+-+--+:0.5^4*0.5^2\n+----+:0.5^4*0.5^2\n...\n")])])]),n("p",[t._v("把图画出来就好做了：\n"),n("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/10/595088041.png",alt:"3.png"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("a:--(--)*-+:0.5^2*(0.5^2+0.5^4+...+0.5^2n) =0.25*（0.25(1-0.25^n)/0.75）=\nb:--(--)*+-:0.5*(0.5^2+0.5^4+...+0.5^2n)=0.5*（0.25(1-0.25^n)/0.75）\ns=a+b 表示以--开头 =0.75*（0.25(1-0.25^n)/0.75）\nc:+-(+-)*-+:0.5^2*(0.5^2+0.5^4+...+0.5^2n)=0.25*（0.25(1-0.25^n)/0.75）\nd:+-(+-)*s:(0.5^2+0.5^4+...+0.5^2n)*s=（0.25(1-0.25^n)/0.75）* 0.75*（0.25(1-0.25^n)/0.75）\ne:-+:0.5^2=0.25\n")])])]),n("p",[t._v("所得概率=a+b+c+d+e="),n("code",[t._v("0.25+（0.25(1-0.25^n)/0.75）*(1+ 0.75*（0.25(1-0.25^n)/0.75）)")]),t._v("\n="),n("code",[t._v("0.25+1/3*(1+3/4*1/3)=2/3")])]),t._v(" "),n("blockquote",[n("p",[n("strong",[t._v("故甲赢概率是2/3 乙赢概率是1/3")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);