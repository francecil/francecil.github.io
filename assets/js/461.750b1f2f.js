(window.webpackJsonp=window.webpackJsonp||[]).push([[461],{1360:function(a,e,v){"use strict";v.r(e);var t=v(30),_=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("p",[a._v("Web 缓存分为浏览器缓存和服务端缓存，本文主要描述的是浏览器缓存中的 HTTP 缓存")]),a._v(" "),e("h1",{attrs:{id:"查看缓存文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看缓存文件"}},[a._v("#")]),a._v(" 查看缓存文件")]),a._v(" "),e("p",[a._v("chrome 可以通过 "),e("code",[a._v("chrome://view-http-cache")]),a._v(" 查看浏览器的缓存文件")]),a._v(" "),e("blockquote",[e("p",[a._v("chrome 66 后就用不了了")])]),a._v(" "),e("p",[a._v("pc 上的实际存储位置")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("\\User\\{user}\\AppData\\Local\\google\\Chrome\\User Data\\Default\\Cache\\index 的文件内容\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("火狐可以通过 "),e("code",[a._v("about:cache")]),a._v(" 查看缓存文件列表")]),a._v(" "),e("p",[a._v("进入缓存文件详情页，可以看到缓存文件内容由三部分组成")]),a._v(" "),e("ul",[e("li",[a._v("资源请求地址")]),a._v(" "),e("li",[a._v("响应头")]),a._v(" "),e("li",[a._v("原文件的二进制内容")])]),a._v(" "),e("p",[a._v("而实际的缓存文件也是包含这些部分的，我们可以通过 ChromeCacheView 工具查看内部内容")]),a._v(" "),e("p",[a._v("通过下面几个问题来学习 pc 上浏览器缓存如何设计的")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("是不是应该有一个列表文件记录所有缓存文件的基本信息？")])]),a._v(" "),e("li",[e("p",[a._v("不能直接拿到缓存源文件，每次命中缓存都需要解码文件？")])]),a._v(" "),e("li",[e("p",[a._v("从如果删了缓存文件，是删了什么东西？列表文件内容会相应的修改不？")])]),a._v(" "),e("li",[e("p",[a._v("不会出现列表文件内容还在但是对应缓存原文件被删除的情况？")])])]),a._v(" "),e("p",[a._v("TODO")]),a._v(" "),e("h1",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),e("h2",{attrs:{id:"cache-control-响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-响应头"}},[a._v("#")]),a._v(" Cache-Control 响应头")]),a._v(" "),e("p",[a._v("优先级比 "),e("code",[a._v("Expires")]),a._v(" 高，且用的是相对时间，不需要担心客户端与服务端时间不一致带来的缓存失效问题")]),a._v(" "),e("h3",{attrs:{id:"max-age"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#max-age"}},[a._v("#")]),a._v(" max-age")]),a._v(" "),e("p",[a._v("指定缓存的有效期")]),a._v(" "),e("h3",{attrs:{id:"s-maxage"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#s-maxage"}},[a._v("#")]),a._v(" s-maxage")]),a._v(" "),e("p",[a._v("指定代理缓存（如cdn缓存）的有效期，优先级比 max-age 高")]),a._v(" "),e("h3",{attrs:{id:"no-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#no-cache"}},[a._v("#")]),a._v(" no-cache")]),a._v(" "),e("p",[a._v("不使用本地缓存和代理缓存")]),a._v(" "),e("h3",{attrs:{id:"no-store"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#no-store"}},[a._v("#")]),a._v(" no-store")]),a._v(" "),e("p",[a._v("禁用缓存")]),a._v(" "),e("h3",{attrs:{id:"public"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#public"}},[a._v("#")]),a._v(" public")]),a._v(" "),e("p",[a._v("可以被所有用户缓存，包括终端用户以及 CDN 等中间代理服务器")]),a._v(" "),e("p",[a._v("默认值")]),a._v(" "),e("h3",{attrs:{id:"private"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#private"}},[a._v("#")]),a._v(" private")]),a._v(" "),e("p",[a._v("仅能被终端用户缓存")]),a._v(" "),e("h3",{attrs:{id:"stale-while-revalidate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stale-while-revalidate"}},[a._v("#")]),a._v(" stale-while-revalidate")]),a._v(" "),e("ol",[e("li",[a._v("非缓存标准，属于缓存拓展，实验性质，仅部分浏览器可用。")]),a._v(" "),e("li",[a._v("和 "),e("code",[a._v("max-age")]),a._v(" 配合使用。若 "),e("code",[a._v("max-age")]),a._v(" 过期，而 "),e("code",[a._v("stale-while-revalidate")]),a._v(" 还在有效期内，仅继续使用强缓存，并额外发送一个请求去刷新缓存；而如果 "),e("code",[a._v("stale-while-revalidate")]),a._v(" 也过期，则正常重新刷新。")])]),a._v(" "),e("p",[a._v("举例：max-age=60, stale-while-revalidate=10;")]),a._v(" "),e("ul",[e("li",[a._v("在 60s 内访问请求都将命中强缓存")]),a._v(" "),e("li",[a._v("在 60~70s 内访问请求，先使用强缓存，并额外请求一次去更新缓存（包括有效期）")]),a._v(" "),e("li",[a._v("60~70s内有请求的情况下，在 80s 时请求，将命中强缓存")]),a._v(" "),e("li",[a._v("60~70s内没有请求的情况下，在 80s 时请求，无缓存可用，发起新的请求")])]),a._v(" "),e("p",[a._v("实际可用的场景较少，了解就好。大部分需求场景可以通过 js 解决，参考 js 的 swr 库，其实就是利用了 stale-while-revalidate 的思想。")]),a._v(" "),e("p",[a._v("更多资料详见：")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://web.dev/stale-while-revalidate/",target:"_blank",rel:"noopener noreferrer"}},[a._v("使用 stale-while-revalidate 保持新鲜度 - web.dev"),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"expires-响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires-响应头"}},[a._v("#")]),a._v(" Expires 响应头")]),a._v(" "),e("p",[a._v("表示资源过期时间，以服务端时间为准")]),a._v(" "),e("h1",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),e("h2",{attrs:{id:"last-modified-响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-响应头"}},[a._v("#")]),a._v(" Last-modified 响应头")]),a._v(" "),e("p",[a._v("表示服务端文件的最后修改时间")]),a._v(" "),e("p",[a._v("当缓存过期时，再次发起请求，会带个 "),e("code",[a._v("If-Modified-Since")]),a._v(" 请求头，其值为之前返回的 "),e("code",[a._v("Last-modified")]),a._v(" 响应头的值")]),a._v(" "),e("p",[a._v("服务端会去查询在该时间点后文件是否被修改，若被修改，返回新的资源, 200 响应以及 "),e("code",[a._v("Last-modified")]),a._v(" 的新值；否则返回 304 响应，根据 Cache-Control 或 Expires 重新设置过期时间")]),a._v(" "),e("h2",{attrs:{id:"etag-响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-响应头"}},[a._v("#")]),a._v(" ETag 响应头")]),a._v(" "),e("p",[a._v("由于 "),e("code",[a._v("Last-modified")]),a._v(" 只精确到秒，且如果内容没变但是最后修改时间变了，还是会当新资源请求")]),a._v(" "),e("p",[a._v("于是 http1.1 加了一个 "),e("code",[a._v("ETag")]),a._v(" 响应头")]),a._v(" "),e("p",[a._v("其值为根据文件内容生成的 hash")]),a._v(" "),e("p",[a._v("当缓存过期时，再次发起请求，会带上 "),e("code",[a._v("If-None-Match")]),a._v(" 请求头，其值为之前返回的 "),e("code",[a._v("ETag")]),a._v(" 响应头的值")]),a._v(" "),e("p",[a._v("服务器会去该值和服务器文件的 hash 进行比对，若不同，返回新的资源和 200 响应以及 "),e("code",[a._v("ETag")]),a._v(" 的新值；否则返回 304 响应，根据 Cache-Control 或 Expires 重新设置过期时间")]),a._v(" "),e("p",[e("strong",[a._v("优先级比 "),e("code",[a._v("Last-modified")]),a._v(" 高")])]),a._v(" "),e("p",[a._v("当两个同时存在时，先判断 ETag ，如果 hash 值没有变化，再去判断 "),e("code",[a._v("Last-modified")]),a._v(" ，最终决定是否返回 304")]),a._v(" "),e("h1",{attrs:{id:"总流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总流程"}},[a._v("#")]),a._v(" 总流程")]),a._v(" "),e("p",[a._v("借用 [浅谈 Web 缓存] 中的图")]),a._v(" "),e("p",[e("img",{attrs:{src:"http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8761.png",alt:"alloyteam"}})]),a._v(" "),e("h1",{attrs:{id:"用户行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户行为"}},[a._v("#")]),a._v(" 用户行为")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("用户操作")]),a._v(" "),e("th",[a._v("强缓存")]),a._v(" "),e("th",[a._v("协商缓存")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("前进后退")]),a._v(" "),e("td",[a._v("有效")]),a._v(" "),e("td",[a._v("有效")])]),a._v(" "),e("tr",[e("td",[a._v("地址栏回车")]),a._v(" "),e("td",[a._v("?")]),a._v(" "),e("td",[a._v("有效")])]),a._v(" "),e("tr",[e("td",[a._v("按刷新按钮")]),a._v(" "),e("td",[a._v("无效")]),a._v(" "),e("td",[a._v("有效")])]),a._v(" "),e("tr",[e("td",[a._v("F5")]),a._v(" "),e("td",[a._v("无效")]),a._v(" "),e("td",[a._v("有效")])]),a._v(" "),e("tr",[e("td",[a._v("ctrl + F5")]),a._v(" "),e("td",[a._v("无效")]),a._v(" "),e("td",[a._v("无效")])]),a._v(" "),e("tr",[e("td",[a._v("Disable cache")]),a._v(" "),e("td",[a._v("无效")]),a._v(" "),e("td",[a._v("无效")])])])]),a._v(" "),e("p",[a._v("前四种针对的是文档请求，后两者针对的是所有资源的请求")]),a._v(" "),e("p",[a._v("强缓存失效的原因在于浏览器会在请求中带上"),e("code",[a._v("cache-control: max-age=0")])]),a._v(" "),e("p",[a._v("协商缓存失效的原因在于本该带上 "),e("code",[a._v("If-Modified-Since")]),a._v(" 或 "),e("code",[a._v("If-None-Match")]),a._v(" 请求头，但是浏览器没有带上，并带上以下两个请求头避免强缓存，因此会重新加载资源")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: no-cache\nPragma: no-cache\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("p",[a._v("前进后退是浏览器直接拿缓存页面，即使强缓存已经过期，所以即使断网了，后退还是能访问原来页面文档，参考自：https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.13")]),a._v(" "),e("blockquote",[e("p",[a._v("会发现此时网络请求头显示 Provisional headers are shown")])]),a._v(" "),e("p",[a._v("地址栏回车之所以不固定，在于当前文档链接与要回车的链接是否相同。如果相同，浏览器会认为这是打算 f5 刷新，强缓存无效，否则强缓存有效")]),a._v(" "),e("p",[a._v("最后两种的区别在于，前者会走内存缓存（相同请求命中内存缓存，不会再发一条请求），后者什么缓存都不走；")]),a._v(" "),e("blockquote",[e("p",[a._v("放入内存缓存的是页面扫描加载的，脚步异步请求的不放内存中（没做完整的测试，不确定）")])]),a._v(" "),e("h1",{attrs:{id:"常见问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[a._v("#")]),a._v(" 常见问题")]),a._v(" "),e("h2",{attrs:{id:"请求头出现-provisional-headers-are-shown-的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求头出现-provisional-headers-are-shown-的原因"}},[a._v("#")]),a._v(" 请求头出现 Provisional headers are shown 的原因")]),a._v(" "),e("ol",[e("li",[a._v("插件拦截")]),a._v(" "),e("li",[a._v("命中本地缓存")]),a._v(" "),e("li",[a._v("服务器超时")]),a._v(" "),e("li",[e("strong",[a._v("跨域拦截")]),a._v("，最经常出现的情况，非同源的资源请求都会显示这个")])]),a._v(" "),e("h2",{attrs:{id:"响应头未设置-cache-control-和-expires-还会命中强缓存么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应头未设置-cache-control-和-expires-还会命中强缓存么"}},[a._v("#")]),a._v(" 响应头未设置 cache-control 和 expires 还会命中强缓存么？")]),a._v(" "),e("p",[a._v("对于前进后退的场景来说，有没有这些响应头，都会命中强缓存")]),a._v(" "),e("p",[a._v("其他场景则不会命中")]),a._v(" "),e("h2",{attrs:{id:"如何设置才能不缓存资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何设置才能不缓存资源"}},[a._v("#")]),a._v(" 如何设置才能不缓存资源")]),a._v(" "),e("h2",{attrs:{id:"通过-expires-判断缓存过期-而本地时间比服务器时间快的话-会出现什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过-expires-判断缓存过期-而本地时间比服务器时间快的话-会出现什么问题"}},[a._v("#")]),a._v(" 通过 Expires 判断缓存过期，而本地时间比服务器时间快的话，会出现什么问题？")]),a._v(" "),e("p",[a._v("如果通过 Expires 判断缓存过期，而本地时间又比服务端快资源有效期以上，就会出现始终不能命中强缓存的情况")]),a._v(" "),e("h1",{attrs:{id:"浏览器缓存中的其他缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存中的其他缓存"}},[a._v("#")]),a._v(" 浏览器缓存中的其他缓存")]),a._v(" "),e("p",[a._v("读取某个 url 的资源，按照下面的过程")]),a._v(" "),e("p",[a._v("（需要做个试验）")]),a._v(" "),e("p",[a._v("内存缓存")]),a._v(" "),e("blockquote",[e("p",[a._v("preload 预加载的资源会存储在此处\n当前页面已经加载过的资源会放在内存中，方便读取\n但注意一点，如果资源设置了 no-store ，前面即使加载过这个资源，还是会继续加载（待确定）")])]),a._v(" "),e("p",[a._v("Service Worker 缓存")]),a._v(" "),e("blockquote",[e("p",[a._v("有一套自己的缓存API，更加可控，不受浏览器影响")])]),a._v(" "),e("p",[a._v("HTTP 缓存")]),a._v(" "),e("blockquote",[e("p",[a._v("上文提到的那个，根据请求响应等头部信息确定是否走缓存")])]),a._v(" "),e("p",[a._v("HTTP2 Push 缓存")]),a._v(" "),e("blockquote",[e("p",[a._v("有一定的时效，chromium 中是五分钟\n在命中缓存后，可能会在 HTTP 缓存中增加拷贝以及内存缓存增加引用")])]),a._v(" "),e("h1",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"http://www.alloyteam.com/2016/03/discussion-on-web-caching/",target:"_blank",rel:"noopener noreferrer"}},[a._v("浅谈 Web 缓存"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://www.cnblogs.com/wonyun/p/5524617.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("http协商缓存VS强缓存"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control",target:"_blank",rel:"noopener noreferrer"}},[a._v("Cache-Control"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/5aa5ddd4f265da23906ba592",target:"_blank",rel:"noopener noreferrer"}},[a._v("【译】关于四种缓存的故事"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);