(window.webpackJsonp=window.webpackJsonp||[]).push([[379],{1166:function(e,t,a){"use strict";a.r(t);var r=a(30),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("hr"),e._v(" "),t("h2",{attrs:{id:"_2016-04-14"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2016-04-14"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2016/04/14")])]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("HelloOpenGlES")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("先建项目,MainActivity")]),e._v(" "),t("p",[e._v('public class MainActivity extends AppCompatActivity {\nprivate GLSurfaceView glSurfaceView;\nprivate boolean rendererSet = false;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\n//用GLSurfaceView 初始化OpenGL 为显示GL surface\nglSurfaceView=new GLSurfaceView(this);\n/*\n* 检查OpenGl ES版本\n* */\nfinal ActivityManager activityManager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);\nfinal ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\nfinal boolean supportEs2 =configurationInfo.reqGlEsVersion >=0x20000;\nLog.i("zjx",configurationInfo.reqGlEsVersion+";;;");//输出196608 16进制=0x30000 3.0版本\nif(supportEs2){\n//为了兼容2.0版本的 这边不设置Version为3\nglSurfaceView.setEGLContextClientVersion(2);\n//传入一个自定义Renderer渲染器\nglSurfaceView.setRenderer(new FirstRenderer());\nrendererSet = true ;\n//显示在屏幕上\nsetContentView(glSurfaceView);\n}\n}\n@Override\nprotected void onPause() {\nsuper.onPause();\n//暂停surfaceView,释放OpenGl上下文\nif(rendererSet){\nglSurfaceView.onPause();\n}\n}')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  @Override\n  protected void onResume() {\n      super.onResume();\n      //继续后台渲染线程，续用OpenGL上下文\n      if(rendererSet){\n          glSurfaceView.onResume();\n      }\n  }\n")])])]),t("p",[e._v("}")])])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("先建FirstRenderer")]),e._v(" "),t("p",[e._v("import android.opengl.GLSurfaceView;\nimport android.util.Log;")]),e._v(" "),t("p",[e._v("import static android.opengl.GLES20.*;\nimport javax.microedition.khronos.egl.EGLConfig;\nimport javax.microedition.khronos.opengles.GL10;")]),e._v(" "),t("p",[e._v("/**")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Created by Administrator on 2016/3/29.")])]),e._v(" "),t("li",[t("p",[e._v("采用静态import GLES20 所以下面的glClearColor等静态方法/变量 无需写类名")])]),e._v(" "),t("li",[t("p",[e._v("GLSurfaceView 会在单独的线程调用渲染器的方法")])]),e._v(" "),t("li",[t("p",[e._v("后台渲染线程和主线程(UI线程)通信可以用runOnUIThread()来传递event\n"),t("em",[e._v("/\npublic class FirstRenderer implements GLSurfaceView.Renderer {\n/")])]),e._v(" "),t("ul",[t("li",[e._v("surface创建时调用")]),e._v(" "),t("li",[e._v("@parem gl10: 1.0遗留 为向下兼容")]),e._v(" "),t("li",[e._v("ps:横竖屏切换时，会调用，重新获得OpenGL 上下文会再调用(pause->resume)")]),e._v(" "),t("li",[e._v('*/\n@Override\npublic void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\nLog.i("zjx1","onSurfaceCreated");\nglClearColor(1.0f,1.0f,0.0f,0.5f);\n}')])]),e._v(" "),t("p",[e._v("/*")]),e._v(" "),t("ul",[t("li",[e._v("surface尺寸变化时调用,")]),e._v(" "),t("li",[e._v("ps:横竖屏切换时，surface尺寸会发生变化")]),e._v(" "),t("li",[t("em",[e._v('/\n@Override\npublic void onSurfaceChanged(GL10 gl10, int width, int height) {\n//设置视口尺寸，渲染surface的大小\nLog.i("zjx2","onSurfaceChanged");\nglViewport(0,0,width/2,height/2);\n}\n/')]),e._v("\n*每绘制一帧，都会被GLSurfaceView调用，所以在该方法一定要绘制东西，即使只是clear screen")]),e._v(" "),t("li",[e._v("because after this method, 渲染缓冲区会被交换显示到屏幕上，")]),e._v(" "),t("li",[e._v("否则会出现闪屏效果")]),e._v(" "),t("li",[e._v('*/\n@Override\npublic void onDrawFrame(GL10 gl10) {\nLog.i("zjx3","onDrawFrame");\nglClear(GL_COLOR_BUFFER_BIT);\n}\n}')])])])])])]),e._v(" "),t("p",[e._v("效果：黄色的screen,旋转屏幕/回到Activity 打印相应log")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_2016-04-15"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2016-04-15"}},[e._v("#")]),e._v(" 2016/04/15")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"定义顶点和着色器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义顶点和着色器"}},[e._v("#")]),e._v(" 定义顶点和着色器")]),e._v(" "),t("h3",{attrs:{id:"定义顶点-且复制到本地内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义顶点-且复制到本地内存"}},[e._v("#")]),e._v(" 定义顶点，且复制到本地内存")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class AirHockeyRenderer implements GLSurfaceView.Renderer {\n    private static final int POSITION_COMPONENT_COUNT = 2;\n    private static final int BYTES_PER_FLOAT = 4;\n    private final FloatBuffer vertexData;//本地内存存储数据\n    /*\n    * surface创建时调用\n    * @parem gl10: 1.0遗留 为向下兼容\n    * ps:横竖屏切换时，会调用，重新获得OpenGL 上下文会再调用(pause->resume)\n    * */\n    public AirHockeyRenderer(){\n        //逆时针 两个三角形去拼接为矩形\n        float[] tableVerticesWithTriangles ={\n                //Triangle1\n                0f,0f,\n                9f,14f,\n                0f,14f,\n                //Triangle2\n                0f,0f,\n                9f,0f,\n                9f,14f,\n                //line\n                0f,7f,\n                9f,7f,\n                //Mallets\n                4.5f,2f,\n                4.5f,12f\n        };\n        vertexData = ByteBuffer.allocateDirect(tableVerticesWithTriangles.length * BYTES_PER_FLOAT)//分配本地内存\n                .order(ByteOrder.nativeOrder())//保证一个平台使用同样的排序：按照本地字节序组织内容\n                .asFloatBuffer();//不操作字节 而是希望调用浮点数\n        vertexData.put(tableVerticesWithTriangles);//把数据从Dalvik内存复制到本地内存 进程结束时释放内存\n\n\n    }\n")])])]),t("h3",{attrs:{id:"顶点着色器-生成每个顶点的对应位置-每个顶点都会执行一次-最终位置确定后组装为点线三角形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顶点着色器-生成每个顶点的对应位置-每个顶点都会执行一次-最终位置确定后组装为点线三角形"}},[e._v("#")]),e._v(" 顶点着色器：生成每个顶点的对应位置，每个顶点都会执行一次，最终位置确定后组装为点线三角形")]),e._v(" "),t("h3",{attrs:{id:"片段着色器-为组成点-直线-三角形每个片段-超小单一颜色-类似像素-生成最终的颜色-每个片段调用一次。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#片段着色器-为组成点-直线-三角形每个片段-超小单一颜色-类似像素-生成最终的颜色-每个片段调用一次。"}},[e._v("#")]),e._v(" 片段着色器：为组成点 直线 三角形每个片段(超小单一颜色，类似像素)生成最终的颜色，每个片段调用一次。")]),e._v(" "),t("p",[t("em",[e._v("颜色生成后，OpenGL将其写入帧缓冲区(frame buffer) 然后Android将该缓冲区显示到屏幕上。")])]),e._v(" "),t("blockquote",[t("p",[e._v("过程：读取顶点数据->执行顶点着色器->组装图元->光栅化图元->执行片段着色器->写入帧缓冲区->显示到屏幕上\ncookbook:https://www.khronos.org/files/opengles20-reference-card.pdf")])]),e._v(" "),t("h3",{attrs:{id:"创建第一个顶点着色器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建第一个顶点着色器"}},[e._v("#")]),e._v(" 创建第一个顶点着色器")]),e._v(" "),t("p",[e._v("res/raw下新建simple_vertex_shader.glsl")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//类似c语言\nattribute vec4 a_Position;\n//着色器入口\nvoid main(){\n    gl_Position = a_Position;//OpenGL会把gl_Position中存储的值作为当前顶点的最终位置。\n}\n")])])]),t("h3",{attrs:{id:"创建第一个片段着色器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建第一个片段着色器"}},[e._v("#")]),e._v(" 创建第一个片段着色器")]),e._v(" "),t("h4",{attrs:{id:"光栅化技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#光栅化技术"}},[e._v("#")]),e._v(" 光栅化技术")]),e._v(" "),t("blockquote",[t("p",[e._v("OpenGL通过光栅化技术把每个点，直线及三角形分解为大量的小片段，如图2-7\n"),t("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/04/3916412237.jpg",alt:"FUL[{SAR9]74$1KAABMH3AA.jpg"}})])]),e._v(" "),t("blockquote",[t("p",[e._v("通常一个片段对应一个像素，高分屏的可能片段较大较少CPU负荷")])]),e._v(" "),t("blockquote",[t("p",[e._v("simple_fragment_shader.glsl")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//定义浮点数精度：lowp/mediumn/highp 低/中/高 精度 精度越高性能越低\n//顶点着色器默认是highp:顶点位置精度重要\nprecision mediump float;\nuniform vec4 u_Color;\n\nvoid main(){\n    gl_FragColor = u_Color;//OpenGL会把gl_FragColor中存储的这个颜色作为当前片段的最终颜色\n}\n")])])]),t("h3",{attrs:{id:"opengl颜色模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#opengl颜色模型"}},[e._v("#")]),e._v(" OpenGl颜色模型")]),e._v(" "),t("p",[e._v("(R,G,B,Alpha)")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"编译着色器及在屏幕上绘图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译着色器及在屏幕上绘图"}},[e._v("#")]),e._v(" 编译着色器及在屏幕上绘图")]),e._v(" "),t("h3",{attrs:{id:"加载着色器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载着色器"}},[e._v("#")]),e._v(" 加载着色器")]),e._v(" "),t("h4",{attrs:{id:"新建工具类-textresourcereader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新建工具类-textresourcereader"}},[e._v("#")]),e._v(" 新建工具类 TextResourceReader")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('/**\n * Created by Administrator on 2016/4/15.\n * 从资源中加载文本\n */\npublic class TextResourceReader {\n    public static String readTextFileFromResource(Context context, int resourceId){\n        StringBuilder body = new StringBuilder();//不考虑同步写入，用Builder\n        try{\n            InputStream inputStream = context.getResources().openRawResource(resourceId);\n            InputStreamReader inputStreamReader=new InputStreamReader(inputStream);\n            BufferedReader bufferedReader=new BufferedReader(inputStreamReader);\n            String nexttLine;\n            while((nexttLine=bufferedReader.readLine())!=null){\n                body.append(nexttLine);\n                body.append(\'\\n\');\n            }\n        }catch (IOException e){\n            throw new RuntimeException("不能打开资源："+resourceId,e);\n        }catch (Resources.NotFoundException nfe){\n            throw new RuntimeException("资源不存在："+resourceId,nfe);\n        }\n        return body.toString();\n    }\n}\n')])])]),t("h4",{attrs:{id:"读入着色器代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读入着色器代码"}},[e._v("#")]),e._v(" 读入着色器代码")]),e._v(" "),t("p",[e._v("修改AirHockeyRenderer为如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public class AirHockeyRenderer implements GLSurfaceView.Renderer {\n    private static final int POSITION_COMPONENT_COUNT = 2;\n    private static final int BYTES_PER_FLOAT = 4;\n    private final FloatBuffer vertexData;//本地内存存储数据\n    private final Context context;\n    /*\n    * surface创建时调用\n    * @parem gl10: 1.0遗留 为向下兼容\n    * ps:横竖屏切换时，会调用，重新获得OpenGL 上下文会再调用(pause->resume)\n    * */\n    public AirHockeyRenderer(Context context){\n        this.context=context;\n        //逆时针 两个三角形去拼接为矩形\n        float[] tableVerticesWithTriangles ={\n               //不变 略\n        };\n        vertexData = ByteBuffer.allocateDirect(tableVerticesWithTriangles.length * BYTES_PER_FLOAT)//分配本地内存\n                .order(ByteOrder.nativeOrder())//保证一个平台使用同样的排序：按照本地字节序组织内容\n                .asFloatBuffer();//不操作字节 而是希望调用浮点数\n        vertexData.put(tableVerticesWithTriangles);//把数据从Dalvik内存复制到本地内存 进程结束时释放内存\n\n\n    }\n    @Override\n    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n\n        Log.i("zjx1","onSurfaceCreated");\n        glClearColor(1.0f,1.0f,0.0f,0.5f);\n        String vertexShaderSource = TextResourceReader.readTextFileFromResource(context,R.raw.simple_vertex_shader);\n        String fragmentShaderSource = TextResourceReader.readTextFileFromResource(context,R.raw.simple_fragment_shader);\n    }\n')])])]),t("p",[e._v("Activity修改")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" //传入一个自定义Renderer渲染器\n            glSurfaceView.setRenderer(new AirHockeyRenderer(this));\n            rendererSet = true ;\n")])])]),t("h3",{attrs:{id:"编译着色器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译着色器"}},[e._v("#")]),e._v(" 编译着色器")]),e._v(" "),t("h4",{attrs:{id:"新建工具类shaderhelper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新建工具类shaderhelper"}},[e._v("#")]),e._v(" 新建工具类ShaderHelper")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('import android.util.Log;\n\nimport static android.opengl.GLES20.*;\npublic class ShaderHelper {\n    private static final String TAG = "ShaderHelper";\n    public static int compileVertexShader(String shaderCode){\n        return compileShader(GL_VERTEX_SHADER,shaderCode);\n    }\n    public static int compileFragmentShader(String shaderCode){\n        return compileShader(GL_FRAGMENT_SHADER,shaderCode);\n    }\n    /**\n     * 编译着色器, 返回 OpenGL object ID.\n     */\n    private static int compileShader(int type, String shaderCode) {\n        // new 着色器对象\n        //shaderObjectId 是OpenGL对象的引用\n        final int shaderObjectId = glCreateShader(type);\n        //内部实现是返回0而不是抛异常\n        if(shaderObjectId == 0){\n            Log.w(TAG,"没有创建着色器对象");\n            return 0;\n        }\n        //把着色器源代码传到着色器对象中\n        glShaderSource(shaderObjectId,shaderCode);\n        //编译着色器\n        glCompileShader(shaderObjectId);////shaderObjectId 保持着对OpenGL对象(该着色器对象)的引用\n        //得到编译状态\n        final int[] compileStatus = new int[1];\n        //存入compileStatus数组的第0个元素\n        glGetShaderiv(shaderObjectId,GL_COMPILE_STATUS,compileStatus,0);\n        //也可以选择获得更多的编译信息\n        Log.v(TAG, "Results of compiling source:" + "\\n" + shaderCode + "\\n:"\n                + glGetShaderInfoLog(shaderObjectId));\n        if (compileStatus[0] == 0) {\n            // 编译失败，删除对象\n            glDeleteShader(shaderObjectId);\n            Log.w(TAG, "Compilation of shader failed.");\n            return 0;\n        }\n        //编译成功\n        return shaderObjectId;\n    }\n}\n')])])]),t("p",[e._v("修改Renderer")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\n    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n\n        Log.i("zjx1","onSurfaceCreated");\n        glClearColor(1.0f,1.0f,0.0f,0.5f);\n        String vertexShaderSource = TextResourceReader.readTextFileFromResource(context,R.raw.simple_vertex_shader);\n        String fragmentShaderSource = TextResourceReader.readTextFileFromResource(context,R.raw.simple_fragment_shader);\n        int vertexShader = ShaderHelper.compileVertexShader(vertexShaderSource);\n        int fragmentShader = ShaderHelper.compileFragmentShader(fragmentShaderSource);\n    }\n')])])]),t("blockquote",[t("p",[e._v("此时该渲染器已经获得了OpenGL对象(这里是着色器)的引用")])]),e._v(" "),t("h3",{attrs:{id:"链接顶点和片段着色器成为单个对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链接顶点和片段着色器成为单个对象"}},[e._v("#")]),e._v(" 链接顶点和片段着色器成为单个对象")]),e._v(" "),t("p",[e._v("修改ShaderHelper,加入linkProgram方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public static int linkProgram(int vertexShaderId, int fragmentShaderId) {\n        //新建一个program对象，用于后面链接2个着色器\n        final int programObjectId = glCreateProgram();\n        if (programObjectId == 0) {\n            Log.w(TAG, "Could not create new program");\n            return 0;\n        }\n        //附上着色器\n        glAttachShader(programObjectId,vertexShaderId);\n        glAttachShader(programObjectId,fragmentShaderId);\n        //链接\n        glLinkProgram(programObjectId);\n        final int[] linkStatus = new int[1];\n        glGetProgramiv(programObjectId, GL_LINK_STATUS, linkStatus, 0);\n        Log.v(TAG, "Results of linking program:\\n"\n                    + glGetProgramInfoLog(programObjectId));\n        if (linkStatus[0] == 0) {\n            glDeleteProgram(programObjectId);\n            Log.w(TAG, "Linking of program failed.");\n            return 0;\n        }\n        return programObjectId;\n    }\n')])])]),t("p",[e._v("修改AirHockeyRenderer")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("private int program;\n//onSurfaceCreated(){中\n        program=ShaderHelper.linkProgram(vertexShader,fragmentShader);\n")])])]),t("h3",{attrs:{id:"最后的拼接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后的拼接"}},[e._v("#")]),e._v(" 最后的拼接")]),e._v(" "),t("h4",{attrs:{id:"验证opengl对象是否是有效的-低效率-无法运行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验证opengl对象是否是有效的-低效率-无法运行"}},[e._v("#")]),e._v(" 验证OpenGL对象是否是有效的：低效率/无法运行")]),e._v(" "),t("p",[e._v("ShaderHelper加入")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public static boolean validateProgram(int programObjectId) {\n        //检查是否有效\n        glValidateProgram(programObjectId);\n\n        final int[] validateStatus = new int[1];\n        glGetProgramiv(programObjectId, GL_VALIDATE_STATUS, validateStatus, 0);\n        Log.v(TAG, "Results of validating program: " + validateStatus[0]\n                + "\\nLog:" + glGetProgramInfoLog(programObjectId));\n\n        return validateStatus[0] != 0;\n    }\n')])])]),t("blockquote",[t("p",[e._v("onSurfaceOnCreated()加入")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("ShaderHelper.validateProgram(program);\n//告诉OpenGL绘制东西要屏幕上要使用这里的program\nglUseProgram(program);\n")])])]),t("h4",{attrs:{id:"获取uniform和attribute位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取uniform和attribute位置"}},[e._v("#")]),e._v(" 获取uniform和attribute位置")]),e._v(" "),t("p",[e._v("渲染器AirHockeyRenderer头部加入")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('private static final String U_COLOR = "u_Color";\nprivate static final String A_POSITION = "a_Position";\nprivate int uColorLocation;//U_COLOR在OpenGL程序对象中位置的变量\nprivate int aPositionLocation;\n')])])]),t("blockquote",[t("p",[e._v("onSurfaceOnCreated()加入")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//获取uniform和attribute的位置\n        uColorLocation = glGetUniformLocation(program, U_COLOR);\n        aPositionLocation = glGetAttribLocation(program, A_POSITION);\n")])])]),t("blockquote",[t("p",[e._v("onSurfaceOnCreated如下")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\n    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n\n        Log.i("zjx1","onSurfaceCreated");\n        glClearColor(1.0f,1.0f,0.0f,0.5f);\n        String vertexShaderSource = TextResourceReader.readTextFileFromResource(context,R.raw.simple_vertex_shader);\n        String fragmentShaderSource = TextResourceReader.readTextFileFromResource(context,R.raw.simple_fragment_shader);\n        //获取引用\n        int vertexShader = ShaderHelper.compileVertexShader(vertexShaderSource);\n        int fragmentShader = ShaderHelper.compileFragmentShader(fragmentShaderSource);\n        program=ShaderHelper.linkProgram(vertexShader,fragmentShader);\n        ShaderHelper.validateProgram(program);\n        //告诉OpenGL绘制东西要屏幕上要使用这里的program\n        glUseProgram(program);\n        //获取uniform和attribute在program的位置\n        uColorLocation = glGetUniformLocation(program, U_COLOR);\n        aPositionLocation = glGetAttribLocation(program, A_POSITION);\n        //关联attribute(aPositionLocation)与顶点数据vertexData\n        vertexData.position(0);//确保本地内存的vertexData从数组头开始读取\n        /**\n         * glVertexAttribPointer (int index, int size, int type, boolean normalized, int stride, Buffer ptr)\n         * @param index :我们把数据传入attribute位置，指向glGetAttribLocation中获取的位置\n         * @param size:这里我们只用了2个分量(x,y)，注意在着色器中a_Pointion被定义为vec4\n         * @param type:数据类型\n         * @param normalized:只要使用整形该参数才有意义\n         * @param stride:暂时忽略\n         * @param ptr:去哪读数据              \n         * 注意传入正确的参数，否则难以调试\n         */\n        glVertexAttribPointer(aPositionLocation, POSITION_COMPONENT_COUNT, GL_FLOAT,\n                false, 0, vertexData);\n        //告诉OpenGL去aPositionLocation寻找数据,可以从vertexData找到属性为a_Position的数据\n        glEnableVertexAttribArray(aPositionLocation);\n    }\n')])])]),t("h3",{attrs:{id:"绘制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绘制"}},[e._v("#")]),e._v(" 绘制")]),e._v(" "),t("p",[t("strong",[e._v("读入顶点数据后，点着色器得到赋值，值如何寻找在onSurfaceCreated 有定义，然后进入glsl的main函数")]),e._v(" "),t("strong",[e._v("光栅化后有些属性传入片着色器(如下一章讲的用到的varying vec4 v_Color)")]),e._v(" "),t("strong",[e._v("然后最后绘制到屏幕上")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void onDrawFrame(GL10 gl10) {\n        Log.i("zjx3","onDrawFrame");\n        glClear(GL_COLOR_BUFFER_BIT);\n        //更新着色器中u_Color中的值(在onSurfaceCreated中我们已经获取到uniform的位置并存入uColorLocation)\n        // uniform没有默认值 所以这里我们必须指定\n        //先随便设置个RGBA\n        glUniform4f(uColorLocation,1.0f,1.0f,1.0f,1.0f);\n        /*\n        * glDrawArrays (int mode, int first, int count)\n        * mode:我们要画的类型\n        * first:从顶点数组vertexData那个位置开始找\n        * count:读入一个顶点 这里读6个 画出两个三角形\n        * */\n        glDrawArrays(GL_TRIANGLES,0,6);\n        //一些其他的绘制\n        // Draw the center dividing line.\n        glUniform4f(uColorLocation, 1.0f, 0.0f, 0.0f, 1.0f);\n        glDrawArrays(GL_LINES, 6, 2);\n\n        // Draw the first mallet blue.        \n        glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f);\n        glDrawArrays(GL_POINTS, 8, 1);\n\n        // Draw the second mallet red.\n        glUniform4f(uColorLocation, 1.0f, 0.0f, 0.0f, 1.0f);\n        glDrawArrays(GL_POINTS, 9, 1);\n    }\n')])])]),t("p",[e._v("先运行看下效果：\n"),t("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/04/2367850130.png",alt:"tu"}})]),e._v(" "),t("p",[e._v("先")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n\n        Log.i("zjx1","onSurfaceCreated");\n        glClearColor(0.0f,0.0f,0.0f,0.0f);\n')])])]),t("p",[e._v("坐标映射到屏幕\n更新")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("float[] tableVerticesWithTriangles = {\n            // Triangle 1\n            -0.5f, -0.5f, \n             0.5f,  0.5f,\n            -0.5f,  0.5f,\n\n            // Triangle 2\n            -0.5f, -0.5f, \n             0.5f, -0.5f, \n             0.5f,  0.5f,\n\n            // Line 1\n            -0.5f, 0f, \n             0.5f, 0f,\n\n            // Mallets\n            0f, -0.25f, \n            0f,  0.25f\n        };\n")])])]),t("p",[e._v("指定点的大小")]),e._v(" "),t("blockquote",[t("p",[e._v("simple_vertex_shader.glsl")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("void main(){\n    gl_Position = a_Position;//OpenGL会把gl_Position中存储的值作为当前顶点的最终位置。\n    gl_PointSize = 10.0;//OpenGL将点分解为一些以gl_Position为中心的四边形，每个四边形长度为 gl_PointSize\n}\n")])])]),t("p",[e._v("ok 最后的结果\n"),t("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/04/2746729.png",alt:"QQ截图20160415133352.png"}})]),e._v(" "),t("p",[e._v("截图有误... 手机上实际显示中间是有一条红线的")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"增加颜色和着色"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增加颜色和着色"}},[e._v("#")]),e._v(" 增加颜色和着色")]),e._v(" "),t("blockquote",[t("p",[e._v("把每个点定义为一个顶点属性,而不是整个对象都是一个颜色 如上面的一块大白色")])]),e._v(" "),t("blockquote",[t("p",[e._v("若利用绘制大量的三角形，性能内存开销大")])]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("解决方案：平滑地混合一条直线或一个三角形表面每个顶点的颜色")])])]),e._v(" "),t("h3",{attrs:{id:"引入三角形扇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引入三角形扇"}},[e._v("#")]),e._v(" 引入三角形扇")]),e._v(" "),t("p",[e._v("将原来的两个三角形再分，即出现的是矩形被两条对角线平分为4块三角形")]),e._v(" "),t("p",[e._v("OpenGL 自带该类型"),t("code",[e._v("GL_TRIANGLE_FAN")]),e._v(" 所以不用每个三角形再定义一次坐标")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("float[] tableVerticesWithTriangles = {\n            // Triangle Fan\n               0,     0,            \n            -0.5f, -0.5f,             \n             0.5f, -0.5f,\n             0.5f,  0.5f,\n            -0.5f,  0.5f,            \n            -0.5f, -0.5f,\n\n\n\n6个点分边是\n5——————4\n| \\  / |\n|——1——-|\n| /  \\ |\n2/6————3\n\nonDrawFrame中修改为\nglDrawArrays(GL_TRIANGLE_FAN, 0, 6);\n")])])]),t("p",[e._v("运行后效果一致")]),e._v(" "),t("h3",{attrs:{id:"给顶点增加颜色属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#给顶点增加颜色属性"}},[e._v("#")]),e._v(" 给顶点增加颜色属性")]),e._v(" "),t("p",[e._v("更新")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("float[] tableVerticesWithTriangles = {   \n            // Order of coordinates: X, Y, R, G, B\n            \n            // Triangle Fan\n               0f,    0f,   1f,   1f,   1f,         \n            -0.5f, -0.5f, 0.7f, 0.7f, 0.7f,            \n             0.5f, -0.5f, 0.7f, 0.7f, 0.7f,\n             0.5f,  0.5f, 0.7f, 0.7f, 0.7f,\n            -0.5f,  0.5f, 0.7f, 0.7f, 0.7f,\n            -0.5f, -0.5f, 0.7f, 0.7f, 0.7f,\n\n            // Line 1\n            -0.5f, 0f, 1f, 0f, 0f,\n             0.5f, 0f, 1f, 0f, 0f,\n\n            // Mallets\n            0f, -0.25f, 0f, 0f, 1f,\n            0f,  0.25f, 1f, 0f, 0f\n        };\n")])])]),t("p",[e._v("更新着色器,我们不需要再用uniform")]),e._v(" "),t("h3",{attrs:{id:"插值计算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插值计算"}},[e._v("#")]),e._v(" 插值计算")]),e._v(" "),t("blockquote",[t("p",[e._v("simple_vertex_shader.glsl")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("attribute vec4 a_Position;  \nattribute vec4 a_Color;\n\nvarying vec4 v_Color;//三角形中的变量会被混合 越接近顶点出现的颜色与顶点颜色越相近\n\nvoid main()                    \n{                            \n    v_Color = a_Color;\n\t  \n    gl_Position = a_Position;    \n    gl_PointSize = 10.0;          \n}  \n")])])]),t("blockquote",[t("p",[e._v("simple_fragment_shader.glsl")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("precision mediump float; \t\t\t\t\nvarying vec4 v_Color;   //代替了uniform   \t   \t\t\t\t\t\t\t\t\n  \nvoid main()                    \t\t\n{                              \t\n    gl_FragColor = v_Color;                                  \t\t\n}\n")])])]),t("p",[e._v("更新渲染器常量")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('private static final String A_POSITION = "a_Position";\n    private static final String A_COLOR = "a_Color";    \n    private static final int POSITION_COMPONENT_COUNT = 2;\n    private static final int COLOR_COMPONENT_COUNT = 3;    \n    private static final int BYTES_PER_FLOAT = 4;\n    //跨距告诉OpenGL每两个顶点在本地内存需要跳过的数据长度\n    private static final int STRIDE = \n        (POSITION_COMPONENT_COUNT + COLOR_COMPONENT_COUNT) * BYTES_PER_FLOAT;\n    \n    private final FloatBuffer vertexData;\n    private final Context context;\n\n    private int program;\n    private int aPositionLocation;\n    private int aColorLocation;\n')])])]),t("p",[e._v("更新onSurfaceCreated")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//uColorLocation = glGetUniformLocation(program, U_COLOR); 改为\n        aColorLocation = glGetAttribLocation(program,A_COLOR);\n\n...\n\n/**\n         * glVertexAttribPointer (int index, int size, int type, boolean normalized, int stride, Buffer ptr)\n         * @param index :我们把数据传入attribute位置，指向glGetAttribLocation中获取的位置\n         * @param size:这里我们只用了2个分量(x,y)，注意在着色器中a_Pointion被定义为vec4\n         * @param type:数据类型\n         * @param normalized:只要使用整形该参数才有意义\n         * @param stride:跨距\n         * @param ptr:去哪读数据\n         * 注意传入正确的参数，否则难以调试\n         */\n//        glVertexAttribPointer(aPositionLocation, POSITION_COMPONENT_COUNT, GL_FLOAT,\n//                false, 0, vertexData); 改为\n        glVertexAttribPointer(aPositionLocation,POSITION_COMPONENT_COUNT,GL_FLOAT,false,STRIDE,vertexData);\n...函数末尾加入\n//把顶点数据和a_Color关联起来\n    vertexData.position(POSITION_COMPONENT_COUNT);\n    //顶点数据的颜色值从2位置开始，有3个，GL_FLOAT类型,跨距STRIDE,\n    glVertexAttribPointer(aColorLocation,COLOR_COMPONENT_COUNT,GL_FLOAT,false,STRIDE,vertexData);\n    //告诉OpenGL去aColorLocation寻找颜色数据\n    glEnableVertexAttribArray(aColorLocation);\n")])])]),t("h4",{attrs:{id:"更新ondrawframe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新ondrawframe"}},[e._v("#")]),e._v(" 更新onDrawFrame")]),e._v(" "),t("p",[e._v("删除glUniform4f调用即可")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void onDrawFrame(GL10 gl10) {\n        Log.i("zjx3","onDrawFrame");\n        glClear(GL_COLOR_BUFFER_BIT);\n        //更新着色器中u_Color中的值(在onSurfaceCreated中我们已经获取到uniform的位置并存入uColorLocation)\n        // uniform没有默认值 所以这里我们必须指定\n        //先随便设置个RGBA\n        /*\n        * glDrawArrays (int mode, int first, int count)\n        * mode:我们要画的类型\n        * first:从顶点数组vertexData那个位置开始找\n        * count:读入一个顶点 这里读6个 画出三角形扇\n        * */\n        glDrawArrays(GL_TRIANGLE_FAN, 0, 6);\n        //一些其他的绘制\n        // Draw the center dividing line.\n        glDrawArrays(GL_LINES, 6, 2);\n\n        // Draw the first mallet blue.\n        glDrawArrays(GL_POINTS, 8, 1);\n\n        // Draw the second mallet red.\n        glDrawArrays(GL_POINTS, 9, 1);\n    }\n')])])]),t("p",[e._v("//如果运行的时候界面全黑，看调试信息应该我glsl文件还没更新,clean project就可以了。\n运行效果\n"),t("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/04/1269235446.png",alt:"QQ截图20160415183202.png"}})]),e._v(" "),t("hr"),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_2016-04-15-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2016-04-15-2"}},[e._v("#")]),e._v(" 2016/04/15")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"调整屏幕宽高比-旋转屏幕的时候"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调整屏幕宽高比-旋转屏幕的时候"}},[e._v("#")]),e._v(" 调整屏幕宽高比(旋转屏幕的时候")]),e._v(" "),t("p",[e._v("(x,y,z,w)")]),e._v(" "),t("h3",{attrs:{id:"平移矩阵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平移矩阵"}},[e._v("#")]),e._v(" 平移矩阵")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1 0 0 x-offset\n0 1 0 y-offset\n0 0 1 z-offset\n0 0 0 1\n")])])]),t("h3",{attrs:{id:"正交投影-概念自习百度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正交投影-概念自习百度"}},[e._v("#")]),e._v(" 正交投影(概念自习百度)")]),e._v(" "),t("p",[e._v("左右手坐标系统")]),e._v(" "),t("p",[e._v("更新点着色器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("uniform mat4 u_Matrix;//4x4的矩阵\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\n\nvarying vec4 v_Color;\n\nvoid main()                    \n{                            \n    v_Color = a_Color;\n\t  \n    //gl_Position = a_Position;\n    gl_Position = u_Matrix * a_Position;  //进行正交投影\n    gl_PointSize = 10.0;          \n}      \n")])])]),t("p",[e._v("更新渲染器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public class AirHockeyRenderer implements GLSurfaceView.Renderer {\n    private static final String U_MATRIX = "u_Matrix";\n    private final float[] projectionMatrix = new float[16];//用于存储矩阵\n    private int uMatrixLocation;//u_Matrix uniform位置 \n')])])]),t("blockquote",[t("p",[e._v("onSurfaceCreated加入\nuMatrixLocation = glGetUniformLocation(program,U_MATRIX);")])]),e._v(" "),t("h3",{attrs:{id:"创建正交投影矩阵-与横竖屏相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建正交投影矩阵-与横竖屏相关"}},[e._v("#")]),e._v(" 创建正交投影矩阵(与横竖屏相关)")]),e._v(" "),t("blockquote",[t("p",[e._v("import static android.opengl.Matrix.*;")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  final float aspectRatio = width > height ? \n            (float) width / (float) height : \n            (float) height / (float) width;\n\n        if (width > height) {\n            // Landscape\n            orthoM(projectionMatrix, 0, -aspectRatio, aspectRatio, -1f, 1f, -1f, 1f);\n        } else {\n            // Portrait or square\n            orthoM(projectionMatrix, 0, -1f, 1f, -aspectRatio, aspectRatio, -1f, 1f);\n        }   \n")])])]),t("blockquote"),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@Override\npublic void onDrawFrame(GL10 gl10) {\n    glClear(GL_COLOR_BUFFER_BIT);\n    // 加入这句 使uMatrixLocation被赋值\n    glUniformMatrix4fv(uMatrixLocation, 1, false, projectionMatrix, 0);\n")])])]),t("p",[e._v("运行后横竖屏一样(横屏不被压缩)这里不展示效果了")]),e._v(" "),t("p",[e._v("本章重点掌握该函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" /*\n    * @param m:目标数组存储后面生成的矩阵\n    * @param mOffset：起始偏移值\n    * @param left/right:x轴的最小/大范围 ..后面的类似\n    * */\npublic static void orthoM (float[] m, int mOffset, float left, float,right, float bottom, float top, float near, float far)\n")])])]),t("p",[e._v("产生如下的正交投影矩阵")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("2/(right-left)    0               0        -(right+left)/(right-left)\n0             2/(top-bottom)      0        -(top+bottom)/(top-bottom)\n0                 0         -2/(far-near)  -(far+near)/(far-near)\n0                 0               0                  1\n")])])]),t("hr"),e._v(" "),t("h2",{attrs:{id:"三维"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三维"}},[e._v("#")]),e._v(" 三维")]),e._v(" "),t("h3",{attrs:{id:"着色器到屏幕的坐标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#着色器到屏幕的坐标"}},[e._v("#")]),e._v(" 着色器到屏幕的坐标")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("gl_Position")]),e._v("->(透视除法)->"),t("code",[e._v("归一化设备坐标")]),e._v("->(窗口变换)->"),t("code",[e._v("窗口坐标")])])]),e._v(" "),t("p",[t("strong",[e._v("2次变换步骤,3个坐标空间")])]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[t("code",[e._v("gl_Position")])]),e._v("：即(x,y,z,w)，我们定义在顶点坐标中的数据,x,y,z属于[-1,1];")])]),e._v(" "),t("li",[t("p",[t("strong",[t("code",[e._v("透视除法")])]),e._v("：为了创建三维幻象,OpenGL 会把每个gl_Position 的x,y,z分量除于它的w分量\n举例：两个坐标(1,1,1,1),(1,1,1,2)，归一化设备坐标之前，做透视除法\n所以变成(1/1,1/1,1/1),(1/2,1/2,1/2) 所以具有较大w值的被移动到离(0,0,0)更近的位置\n看火车铁轨的这张图,原来大家都是(-1,-1,0)，(1,-1,0),图中的红圈处,除于w后位置都变了\n"),t("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/04/1878902394.png",alt:"9DTXVFE%4379Q2HK3R`0CG3.png"}})]),e._v(" "),t("ul",[t("li",[e._v("同质化坐标：(1,1,1,1),(2,2,2,2),(3,3,3,3)透视除法后归一化到同一坐标，成为同质化")]),e._v(" "),t("li",[e._v("除于w而不是除于z:解耦,保留z便于正交投影和透视投影的切换，z用于深度缓冲区")])])]),e._v(" "),t("li",[t("p",[t("strong",[t("code",[e._v("窗口(viewport)变换")])]),e._v(":通过glViewport()调用告诉OpenGL做变换，\n把(-1,-1,-1)到(1,1,1)之间的范围映射到屏幕上，\n"),t("strong",[e._v("范围之外会被裁剪掉")])])])]),e._v(" "),t("h3",{attrs:{id:"添加w分量创建三维图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加w分量创建三维图"}},[e._v("#")]),e._v(" 添加w分量创建三维图")]),e._v(" "),t("p",[e._v("修改渲染器"),t("code",[e._v("AirHockeyRenderer")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("private static final int POSITION_COMPONENT_COUNT = 4;\n")])])]),t("blockquote"),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("float[] tableVerticesWithTriangles = {   \n            // Order of coordinates: X, Y, Z, W, R, G, B\n            \n            // Triangle Fan\n               0f,    0f, 0f, 1.5f,   1f,   1f,   1f,         \n            -0.5f, -0.8f, 0f,   1f, 0.7f, 0.7f, 0.7f,            \n             0.5f, -0.8f, 0f,   1f, 0.7f, 0.7f, 0.7f,\n             0.5f,  0.8f, 0f,   2f, 0.7f, 0.7f, 0.7f,\n            -0.5f,  0.8f, 0f,   2f, 0.7f, 0.7f, 0.7f,\n            -0.5f, -0.8f, 0f,   1f, 0.7f, 0.7f, 0.7f,            \n\n            // Line 1\n            -0.5f, 0f, 0f, 1.5f, 1f, 0f, 0f,\n             0.5f, 0f, 0f, 1.5f, 1f, 0f, 0f,\n\n            // Mallets\n            0f, -0.4f, 0f, 1.25f, 0f, 0f, 1f,\n            0f,  0.4f, 0f, 1.75f, 1f, 0f, 0f\n        };\n")])])]),t("p",[e._v("clean工程之后(AS2.0支持热代码修改，但是有些代码还是没被更新过去)运行效果(没截全)如下\n"),t("img",{attrs:{src:"https://www.hongweipeng.com/usr/uploads/2016/04/2275896847.png",alt:"QQ截图20160416112253.png"}})]),e._v(" "),t("p",[e._v("PS:上面的w是手动指定，硬编码，实际应该是通过透视投影矩阵自动生成w的值")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_16-04-28"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-04-28"}},[e._v("#")]),e._v(" 16-04-28")]),e._v(" "),t("p",[e._v("code:https://pragprog.com/titles/kbogla/source_code")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"增加纹理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增加纹理"}},[e._v("#")]),e._v(" 增加纹理")]),e._v(" "),t("p",[e._v("纹理可以是图像或数学算法生成的数据\n注意纹理的方向性")]),e._v(" "),t("h3",{attrs:{id:"把纹理加载进opengl中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#把纹理加载进opengl中"}},[e._v("#")]),e._v(" 把纹理加载进OpenGL中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public static int loadTexture(Context context, int resourceId) {\n        final int[] textureObjectIds = new int[1];\n          //生成纹理ID存入textureObjectIds[0]\n        glGenTextures(1, textureObjectIds, 0);\n")])])]),t("h3",{attrs:{id:"加载位图数据并与纹理绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载位图数据并与纹理绑定"}},[e._v("#")]),e._v(" 加载位图数据并与纹理绑定")]),e._v(" "),t("p",[e._v("OpenGL不能直接读取PNG 需要解压缩 利用"),t("code",[e._v("BitmapFactory.decodeResource")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("final BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inScaled = false;\n\n        // Read in the resource\n        final Bitmap bitmap = BitmapFactory.decodeResource(\n            context.getResources(), resourceId, options);\n\n\n\n//GL_TEXTURE_2D:表示这是2D纹理 textureObjectIds[0]：表示告诉OpenGL要绑定到哪个纹理对象的ID\n  glBindTexture(GL_TEXTURE_2D, textureObjectIds[0]); \n")])])]),t("h4",{attrs:{id:"纹理过滤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#纹理过滤"}},[e._v("#")]),e._v(" "),t("strong",[e._v("纹理过滤")]),e._v("：")]),e._v(" "),t("blockquote",[t("p",[e._v("我们的纹理在渲染表面绘制，缩放时纹理元素可能无法精确映射到OpenGL生成的片段")])]),e._v(" "),t("ul",[t("li",[e._v("最近邻过滤：为每个OpenGL片段选择最近的纹理元素\n"),t("ul",[t("li",[e._v("放大：OpenGL片段相对过多，一些片段多出来的会选择最近的，故出现锯齿，")]),e._v(" "),t("li",[e._v("缩小：OpenGL片段不够，一些片段选择原来的，一些片段少掉，故会丢失细节")])])]),e._v(" "),t("li",[t("strong",[e._v("双线性过滤")]),e._v("：使用双线性插值平滑像素之间的过渡，故"),t("strong",[e._v("适合处理放大")])]),e._v(" "),t("li",[e._v("MIP贴图：生成一组优化过的不同大小的纹理，为每个片段选择最合适的级别\n占用更多内存，但渲染更快，用于下面的三线性过滤")]),e._v(" "),t("li",[t("strong",[e._v("三线性过滤")]),e._v("：使用MIP贴图级别之间插值的双线性过滤*(注意与使用MIP贴图的双线性过滤区分，后者与双线性无异，只是作用对象是MIP贴图而不是原纹理图)*\n当使用双线性过滤切换MIP贴图级别，会出现明显跳跃或线条，我们可以切换到三线性过滤\n即：OpenGL在"),t("strong",[e._v("最邻近的MIP贴图级别之间也要插值")]),e._v("，故每个片段用8个纹理元素插值，消除过渡")])]),e._v(" "),t("p",[e._v("故，一般是缩小用三线性，放大用双线性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 放大GL_TEXTURE_MAG_FILTER双线性GL_LINEAR\n// 缩小GL_TEXTURE_MIN_FILTER三线性GL_LINEAR_MIPMAP_LINEAR.\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n")])])]),t("p",[t("strong",[e._v("OpenGL纹理过滤模式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("GL_NEAREST----------------------最近邻过滤\nGL_NEAREST_MIPMAP_NEAREST-------使用MIP贴图的最近邻过滤\nGL_NEAREST_MIPMAP_LINEAR--------使用MIP贴图级别之间插值的最近邻过滤\nGL_LINEAR-----------------------双线性插值\nGL_LINEAR_MIPMAP_NEAREST--------使用MIP贴图的双线性插值\nGL_LINEAR_MIPMAP_LINEAR---------三线性插值（使用MIP贴图级别之间插值的双线性过滤）\n")])])]),t("p",[t("strong",[e._v("每种情况允许的纹理过滤模式")]),e._v(" "),t("strong",[e._v("缩小")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("GL_NEAREST\nGL_NEAREST_MIPMAP_NEAREST\nGL_NEAREST_MIPMAP_LINEAR\nGL_LINEAR\nGL_LINEAR_MIPMAP_NEAREST\nGL_LINEAR_MIPMAP_LINEAR\n")])])]),t("p",[t("strong",[e._v("放大")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("GL_NEAREST\nGL_LINEAR\n")])])]),t("h4",{attrs:{id:"加载纹理到opengl并返回id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载纹理到opengl并返回id"}},[e._v("#")]),e._v(" 加载纹理到OPENGL并返回ID")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 加载bitmap到OpenGL，并复制到当前绑定的纹理对象(之前glBindTexture)\ntexImage2D(GL_TEXTURE_2D, 0, bitmap, 0);\nbitmap.recycle();//bitmap使用后直接释放，省的GC\n// Note: Following code may cause an error to be reported in the\n    // ADB log as follows: E/IMGSRV(20095): :0: HardwareMipGen:\n    // Failed to generate texture mipmap levels (error=3)\n    // No OpenGL error will be encountered (glGetError() will return\n    // 0). If this happens, just squash the source image to be\n    // square. It will look the same because of texture coordinates,\n    // and mipmap generation will work.\n    //生成MIP贴图\n    glGenerateMipmap(GL_TEXTURE_2D);\n  // 完成纹理加载后 最后解除纹理和纹理对象(OpenGL对象)的绑定\n    glBindTexture(GL_TEXTURE_2D, 0);\nreturn textureObjectIds[0];//返回纹理对象ID\n")])])]),t("h3",{attrs:{id:"创建新的着色器集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建新的着色器集合"}},[e._v("#")]),e._v(" 创建新的着色器集合")]),e._v(" "),t("h4",{attrs:{id:"顶点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顶点"}},[e._v("#")]),e._v(" 顶点")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("uniform mat4 u_Matrix;\n\nattribute vec4 a_Position;  \nattribute vec2 a_TextureCoordinates;//2个分量：S坐标和T坐标 传递给插值的v_TextureCoordinates\n\nvarying vec2 v_TextureCoordinates;\n\nvoid main()                    \n{                            \n    v_TextureCoordinates = a_TextureCoordinates;\t  \t  \n    gl_Position = u_Matrix * a_Position;    \n}    \n")])])]),t("h4",{attrs:{id:"片段着色器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#片段着色器"}},[e._v("#")]),e._v(" 片段着色器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("precision mediump float; \n      \t \t\t\t\t\nuniform sampler2D u_TextureUnit;  //二维纹理数据的数组    \t \t\t\t\t\t\t\t\t\nvarying vec2 v_TextureCoordinates;      \t   \t\t\t\t\t\t\t\t\n  \nvoid main()                    \t\t\n{           // 被插值的纹理数据和纹理坐标传递给texture2D着色器函数\n           //即读入纹理中特定坐标的颜色值 把结果赋值给gl_FragColor 设置片段的颜色       \t\n    gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);                           \t\t\n}\n")])])]),t("h3",{attrs:{id:"将顶点数据按物品分离为类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将顶点数据按物品分离为类"}},[e._v("#")]),e._v(" 将顶点数据按物品分离为类")]),e._v(" "),t("h4",{attrs:{id:"裁剪纹理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#裁剪纹理"}},[e._v("#")]),e._v(" 裁剪纹理")]),e._v(" "),t("p",[e._v("...")])])}),[],!1,null,null,null);t.default=n.exports}}]);