(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{1051:function(t,e,n){"use strict";n.r(e);var r=n(29),a=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"首先给上我们的耗时任务-和简单web框架搭建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首先给上我们的耗时任务-和简单web框架搭建"}},[t._v("#")]),t._v(" 首先给上我们的耗时任务，和简单web框架搭建")]),t._v(" "),e("p",[t._v("提供一个0-20的数字，计算前n项和，为了不使得计算太快 每加一次 sleep")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('package com.france.servlet;\n\nimport java.io.IOException;\n\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\npublic class TaskServlet implements Servlet{\n\n\n\t@Override\n\tpublic void service(ServletRequest req, ServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\t\ttry {\n\t\t\t\tint num=Integer.valueOf(req.getParameter("num"));\n\t\t\t\tif(num<=0)throw new Exception("数字<=0");\n\t\t\t\tif(num>=20)throw new Exception("数字>=20");\n\t\t\t\tint sum=calculateSumWithSleep(num,500);\n\t\t\t\tSystem.out.println("计算得到的结果是:"+sum);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t}\n\tprivate int calculateSumWithSleep(int num,long ms){\n\t\tint sum=0;\n\t\tfor(int i=0;i<=num;i++){\n\t\t\tsum+=i;\n\t\t\ttry {\n\t\t\t\tThread.sleep(ms);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic ServletConfig getServletConfig() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getServletInfo() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void init(ServletConfig arg0) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n')])])]),t._v(" "),e("blockquote",[e("p",[t._v("web.xml")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5">\n  <description>MuiltThreadCacheTask</description>\n  <display-name>MuiltThreadCacheTask</display-name>\n  <servlet>\n    <display-name>TaskServlet</display-name>\n    <servlet-name>TaskServlet</servlet-name>\n    <servlet-class>com.france.servlet.TaskServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>TaskServlet</servlet-name>\n    <url-pattern>/TaskServlet</url-pattern>\n  </servlet-mapping>\n  \n  <welcome-file-list>\n    <welcome-file>/index.jsp</welcome-file>\n  </welcome-file-list>\n</web-app>\n')])])]),e("blockquote",[e("p",[t._v("做个测试：http://localhost:8888/MuiltThreadCacheTask/TaskServlet?num=3\n控制台输出6")])]),t._v(" "),e("h2",{attrs:{id:"接下来开始搭建我们的并发缓存框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接下来开始搭建我们的并发缓存框架"}},[t._v("#")]),t._v(" 接下来开始搭建我们的并发缓存框架")]),t._v(" "),e("p",[t._v("先将我们刚刚的执行任务函数改成低耦合方式")]),t._v(" "),e("h3",{attrs:{id:"定义computable接口实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义computable接口实现"}},[t._v("#")]),t._v(" 定义Computable接口实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.france;\n\npublic interface Computable<A, V> {\n\tV compute(A arg)throws InterruptedException;\n}\n")])])]),e("p",[e("strong",[t._v("Memoizer")]),t._v("：用于缓存结果，提供Computable接口并在servlet实现 来执行任务")]),t._v(" "),e("h3",{attrs:{id:"创建memoizer1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建memoizer1"}},[t._v("#")]),t._v(" 创建Memoizer1")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.france.memoizer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.france.Computable;\n\npublic class Memoizer1<A,V> implements Computable<A, V> {\n\tprivate final Map<A,V> cache = new HashMap<A,V>();\n\tprivate final Computable<A, V> c;\n\t@Override\n\tpublic synchronized V compute(A arg) throws InterruptedException {\n\t\t// TODO Auto-generated method stub\n\t\tV result=cache.get(arg);\n\t\tif(result==null){\n\t\t\tresult=c.compute(arg);\n\t\t\tcache.put(arg, result);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic Memoizer1(Computable<A, V> c) {\n\t\tthis.c = c;\n\t}\t\t\n}\n")])])]),e("p",[t._v("先搭好框架，后面再说这边的弊端")]),t._v(" "),e("p",[t._v("修改原来的Servlet")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('package com.france.servlet;\n\nimport java.io.IOException;\n\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\nimport com.france.Computable;\nimport com.france.memoizer.Memoizer1;\n\npublic class TaskServlet implements Servlet{\n\tprivate final long ms=500;\n\tprivate final Computable<Integer,Integer> c =new Computable<Integer,Integer>() {\n\n\t\t@Override\n\t\tpublic Integer compute(Integer arg) throws InterruptedException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn calculateSumWithSleep(arg);\n\t\t}\n\t};\n\t//接口实现子类 可拔插\n\tprivate final Computable<Integer,Integer> cahce=new Memoizer1<Integer,Integer>(c);\n\t\n\t@Override\n\tpublic void service(ServletRequest req, ServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\t\ttry {\n\t\t\t\tint num=Integer.valueOf(req.getParameter("num"));\n\t\t\t\tif(num<=0)throw new Exception("数字<=0");\n\t\t\t\tif(num>=20)throw new Exception("数字>=20");\n\t\t\t\tint sum=this.cahce.compute(num);\n\t\t\t\tSystem.out.println("计算得到的结果是:"+sum);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t}\n\tprivate int calculateSumWithSleep(int num){\n\t\tint sum=0;\n\t\tfor(int i=0;i<=num;i++){\n\t\t\tsum+=i;\n\t\t\ttry {\n\t\t\t\tThread.sleep(ms);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic ServletConfig getServletConfig() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getServletInfo() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void init(ServletConfig arg0) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n')])])]),e("blockquote",[e("p",[t._v("做测试(单机)，第一次执行很慢，第二次执行从cache中拿，很快。")])]),t._v(" "),e("p",[t._v("那么出现的问题是什么呢？")]),t._v(" "),e("blockquote",[e("p",[t._v("首先先明白一点，"),e("code",[t._v("implements Servlet")]),t._v("后，每个线程执行"),e("code",[t._v("service")]),t._v("方法是独立的，而"),e("code",[t._v("cahce")]),t._v("定义为全局变量，所有线程访问的是"),e("strong",[t._v("同一个引用")]),t._v("而不是"),e("strong",[t._v("线程封闭")])])]),t._v(" "),e("p",[t._v("然后，由于"),e("code",[t._v("HashMap")]),t._v("不是线程安全的，为了保证两个线程不会同时访问"),e("code",[t._v("HashMap")]),t._v(","),e("code",[t._v("Memoizer1")]),t._v("采用方法是对整个"),e("code",[t._v("compute")]),t._v("方法进行同步\n虽然能"),e("code",[t._v("确保线程安全")]),t._v("，但是带来的问题是"),e("code",[t._v("其他调用compute的线程被堵塞")]),t._v("，效果上来说比"),e("code",[t._v("不使用cache")]),t._v("更差")]),t._v(" "),e("h3",{attrs:{id:"改进-使用线程安全的concurrenthashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改进-使用线程安全的concurrenthashmap"}},[t._v("#")]),t._v(" "),e("strong",[t._v("改进，使用线程安全的"),e("code",[t._v("ConcurrentHashMap")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.france.memoizer;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.france.Computable;\n\npublic class Memoizer2<A,V> implements Computable<A, V> {\n\t//将\n\tprivate final Map<A,V> cache = new ConcurrentHashMap<A,V>();\n\tprivate final Computable<A, V> c;\n\t//由于线程安全，这里不再使用synchronized\n\t@Override\n\tpublic  V compute(A arg) throws InterruptedException {\n\t\t// TODO Auto-generated method stub\n\t\tV result=cache.get(arg);\n\t\tif(result==null){\n\t\t\tresult=c.compute(arg);\n\t\t\tcache.put(arg, result);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic Memoizer2(Computable<A, V> c) {\n\t\tthis.c = c;\n\t}\n\t\n\t\n}\n")])])]),e("p",[t._v("较之前相比，多线程可并发使用它。\n但是存在一个"),e("code",[t._v("较严重的问题")]),t._v("，"),e("strong",[t._v("两个线程同时调用compute去计算同一个值会造成重复计算")]),t._v("\n当任务耗时更久的时候问题将更严重。")]),t._v(" "),e("blockquote",[e("p",[t._v("图示：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("A  ->f(1)不在缓存->[   计算f(1)    ]->将f(1)放入缓存\nB  -----------\x3ef(1)不在缓存->[   计算f(1)    ]->将f(1)放入缓存\n")])])]),e("p",[t._v("这样就是同样的任务计算了2次并放了2次缓存，对一个"),e("code",[t._v("高效")]),t._v("的缓存框架来说是糟糕的。")]),t._v(" "),e("h3",{attrs:{id:"改进-采用futuretask"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改进-采用futuretask"}},[t._v("#")]),t._v(" "),e("strong",[t._v("改进，采用FutureTask")])]),t._v(" "),e("p",[e("code",[t._v("FutureTask")]),t._v("表示一个计算的过程，可能已经计算完成，也可能正在进行。如果有结果可用，那么"),e("code",[t._v("FutureTask.get")]),t._v("将立即返回结果，否则会一直堵塞，直到计算结果出来再将其返回")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.france.memoizer;\n\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\n\nimport com.france.Computable;\n\n\npublic class Memoizer3<A,V> implements Computable<A, V> {\n\t//将V改成Future<V> Future<V>表示一个得到V的过程\n\tprivate final Map<A,Future<V>> cache = new ConcurrentHashMap<A,Future<V>>();\n\tprivate final Computable<A, V> c;\n\t@Override\n\tpublic  V compute(final A arg) throws InterruptedException {\n\t\t// TODO Auto-generated method stub\n\t\t//获取Future\n\t\tFuture<V> future=cache.get(arg);\n\t\tif(future==null){\n\t\t\tCallable<V> eval=new Callable<V>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic V call() throws Exception {\n\t\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\treturn c.compute(arg);\n\t\t\t\t}\n\t\t\t};\n\t\t\t//定义Callable并传递给Future\n\t\t\tFutureTask<V> ft=new FutureTask<V>(eval);\n\t\t\tfuture=ft;\n\t\t\t//将执行过程Future存在cache后开始run\n\t\t\tcache.put(arg, ft);\n\t\t\tft.run();\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (ExecutionException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic Memoizer3(Computable<A, V> c) {\n\t\tthis.c = c;\n\t}\n\t\n\t\n}\n")])])]),e("p",[t._v("较之前相比，"),e("strong",[t._v("基本不会")]),t._v("出现重复计算同一个值的问题。\n为什么说基本不会而不是完成不会？\n原因在于"),e("code",[t._v("compute中if代码")]),t._v("块是"),e("strong",[t._v("非原子")]),t._v("的"),e("code",[t._v("先检查再执行")]),t._v("操作")]),t._v(" "),e("blockquote",[e("p",[t._v("图示：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("A ->f(1)不在缓存中->将f(1)的future放入缓存->[计算f(1)]->通过get()返回结果\nB ----\x3ef(1)不在缓存中->将f(1)的future放入缓存->[计算f(1)]->通过get()返回结果\n")])])]),e("p",[t._v("虽然几率小，但还是有可能出现。\n"),e("strong",[t._v("复合操作（若没有则添加）"),e("strong",[t._v("是在")]),t._v("底层的Map对象")]),t._v("执行的，这个对象"),e("code",[t._v("不能通过加锁")]),t._v("来确保原子性**(否则map堵塞将导致其他线程访问堵塞)**")]),t._v(" "),e("h3",{attrs:{id:"故使用concurrentmap中的原子方法putifabsent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#故使用concurrentmap中的原子方法putifabsent"}},[t._v("#")]),t._v(" 故使用"),e("strong",[t._v("ConcurrentMap")]),t._v("中的"),e("strong",[t._v("原子方法"),e("code",[t._v("putIfAbsent")])])]),t._v(" "),e("p",[t._v("修改处有注释")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.france.memoizer;\n\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\n\nimport com.france.Computable;\n\n\npublic class Memoizer4<A,V> implements Computable<A, V> {\n\t//实现用的ConcurrentHashMap而不是Map\n\tprivate final ConcurrentHashMap<A,Future<V>> cache = new ConcurrentHashMap<A,Future<V>>();\n\tprivate final Computable<A, V> c;\n\t@Override\n\tpublic  V compute(final A arg) throws InterruptedException {\n\t\t// TODO Auto-generated method stub\n\t\tFuture<V> future=cache.get(arg);\n\t\tif(future==null){\n\t\t\tCallable<V> eval=new Callable<V>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic V call() throws Exception {\n\t\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\treturn c.compute(arg);\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<V> ft=new FutureTask<V>(eval);\n\t\t\tfuture=ft;\n\t\t\t//putIfAbsent 原子方法，详情请看源码 用的是Segment控制\n\t\t\tcache.putIfAbsent(arg, ft);\n\t\t\tft.run();\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (ExecutionException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic Memoizer4(Computable<A, V> c) {\n\t\tthis.c = c;\n\t}\n\t\n\t\n}\n")])])]),e("p",[t._v("这样对于**"),e("code",[t._v("线程安全性")]),e("strong",[t._v("和")]),e("code",[t._v("并发性")]),e("strong",[t._v("来说是很完美的\n但是注意\n"),e("strong",[t._v("缓存的是Future而不是值，会导致"),e("code",[t._v("缓存污染(Cache Pollution)问题")])]),t._v("：\n如果计算被取消或者失败，那么")]),t._v("在计算这个结果时"),e("code",[t._v("(调用get方法时)")]),e("strong",[t._v("将指明")]),t._v("计算过程被取消或者失败"),e("code",[t._v("(抛出异常)")]),t._v("**\n解决：如果Memoizer发现"),e("code",[t._v("计算被取消")]),t._v("或者"),e("code",[t._v("出现RuntimeException")]),t._v("，那么"),e("strong",[t._v("将Future从缓存中移除")]),t._v("，这样之后的计算才可能成功(故我们把之前的操作放在一个"),e("code",[t._v("while(true)循环")]),t._v("中去做)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.france.memoizer;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\n\nimport com.france.Computable;\n\n\npublic class Memoizer5<A,V> implements Computable<A, V> {\n\tprivate final ConcurrentHashMap<A,Future<V>> cache = new ConcurrentHashMap<A,Future<V>>();\n\tprivate final Computable<A, V> c;\n\t@Override\n\tpublic  V compute(final A arg) throws InterruptedException {\n\t\t// TODO Auto-generated method stub\n\t\t//放在一个循环中去操作 抛出异常时 移除cache 重新操作\n\t\twhile(true){\n\t\t\tFuture<V> future=cache.get(arg);\n\t\t\tif(future==null){\n\t\t\t\tCallable<V> eval=new Callable<V>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic V call() throws Exception {\n\t\t\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\t\treturn c.compute(arg);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tFutureTask<V> ft=new FutureTask<V>(eval);\n\t\t\t\tfuture=ft;\n\t\t\t\tcache.putIfAbsent(arg, ft);\n\t\t\t\tft.run();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn future.get();\n\t\t\t}catch(CancellationException e){\n\t\t\t\t//出现异常 删除缓存\n\t\t\t\tcache.remove(arg,future);\n\t\t\t}catch (ExecutionException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tpublic Memoizer5(Computable<A, V> c) {\n\t\tthis.c = c;\n\t}\n\t\n\t\n}\n")])])]),e("p",[t._v("当然，上面还是没有解决"),e("code",[t._v("缓存逾期")]),t._v("和"),e("code",[t._v("缓存清理")]),t._v("的问题\n不清除是要从concurrentHashMap下手还是Future下手，求指教")]),t._v(" "),e("p",[t._v("一个想法是结合LruCache和concurrentHashMap实现自己的框架 待续")]),t._v(" "),e("p",[t._v("参考：<<Java并发编程第五章>>")])])}),[],!1,null,null,null);e.default=a.exports}}]);