(window.webpackJsonp=window.webpackJsonp||[]).push([[289],{1016:function(t,e,n){"use strict";n.r(e);var i=n(27),r=Object(i.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"java-io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-io"}},[t._v("#")]),t._v(" Java IO")]),t._v(" "),e("h2",{attrs:{id:"java-io-file类用于表示文件-目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-io-file类用于表示文件-目录"}},[t._v("#")]),t._v(" "),e("code",[t._v("java.io.File")]),t._v("类用于表示文件（目录）")]),t._v(" "),e("p",[t._v("File类只用于表示文件（目录）的信息（名称、大小等），不能用于文件内容的访问")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('File file = new File("F:\\\\临时文档\\\\958032738");//填入相对或绝对地址\n//判断文件(夹)是否存在\nif(!file.exists())\n\tfile.mkdir(); //创建文件夹\nelse\n\tfile.delete();//删除文件夹\n//是否是一个目录  如果是目录返回true,如果不是目录or目录不存在返回的是false\nSystem.out.println(file.isDirectory());\n//是否是一个文件 如果是文件返回true,如果不是文件or文件不存在返回的是false\nSystem.out.println(file.isFile());\n//new file 的构造方式\nFile file2 = new File("e:\\\\javaio\\\\日记1.txt");\nFile file3 = new File("e:\\\\javaio","日记1.txt");\nif(!file2.exists())\n\ttry {\n\t\tfile2.createNewFile();//创建文件\n\t} catch (IOException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\nelse \n\tfile2.delete();//删除文件\n         //常用的File对象的API\nSystem.out.println(file);//file.toString()的内容 F:\\临时文档\\958032738\nSystem.out.println(file.getAbsolutePath());//绝对地址 F:\\临时文档\\958032738\nSystem.out.println(file.getName());//文件（夹）名   958032738\nSystem.out.println(file.getParent());//父文件夹 toString F:\\临时文档\nSystem.out.println(file.getParentFile().getAbsolutePath());//F:\\临时文档\n//列出该目录下的所有文件(夹) 返回的是文件(夹)的名字数组(非路径)\nString filenames[] = file.list();\nfor(String filename:filenames)\n    System.out.println(filename);\n')])])]),e("blockquote",[e("p",[t._v("目录文件遍历")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("void listDirectory(File dir) throws IOException {\n\t// 如果要遍历子目录下的内容，可以判断是否是子目录再递归，File提供了直接返回file对象的api\n\tFile[] files = dir.listFiles();\n\tif (files != null && files.length > 0) {\n\t\tfor (File mFile : files) {\n\t\t\tif (mFile.isDirectory()) {\n\t\t\t\tlistDirectory(mFile);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(mFile);\n\t\t\t}\n\t\t}\n\t}\n}\n")])])]),e("blockquote",[e("p",[t._v("使用文件(夹)名过滤器"),e("code",[t._v("FilenameFilter")]),t._v(" 去除db结尾的文件")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('\tFile[] files2 = file.listFiles(new FilenameFilter() {\n\t\t\n\t\tpublic boolean accept(File dir, String name) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif(name.length()>0&&name.endsWith("db"))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t});\n\tfor (File mFile : files2) {\n\t\tSystem.out.println(mFile);\n\t}\n')])])]),e("blockquote",[e("p",[t._v("文件过滤器"),e("code",[t._v("FileFilter")]),t._v("，pathname是file对象，可以直接处理")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("\tFile[] files = file.listFiles(new FileFilter() {\n\n\t\tpublic boolean accept(File pathname) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif (pathname.isDirectory())\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t});\n\tfor (File mFile : files) {\n\t\tSystem.out.println(mFile);\n\t}\n")])])]),e("h2",{attrs:{id:"randomaccessfile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#randomaccessfile"}},[t._v("#")]),t._v(" "),e("code",[t._v("RandomAccessFile")])]),t._v(" "),e("p",[t._v("java提供的对文件内容的访问，既可以读文件，也可以写文件。\n"),e("code",[t._v("RandomAccessFile")]),t._v("支持随机访问文件，可以访问文件的任意位置")]),t._v(" "),e("p",[e("strong",[t._v("(1)java文件模型")]),t._v("\n在硬盘上的文件是byte byte byte存储的,是数据的集合\n"),e("strong",[t._v("(2)打开文件")]),t._v('\n有两种模式"rw"(读写)  "r"（只读)')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('RandomAccessFile raf = new RandomeAccessFile(file,"rw")\n')])])]),e("p",[t._v("文件指针，打开文件时指针在开头 "),e("code",[t._v("raf.getFilePointer() = 0;")])]),t._v(" "),e("p",[e("strong",[t._v("(3) 写方法")]),t._v(" "),e("code",[t._v("raf.write(int)")]),t._v("---\x3e只写一个字节（后8位),同时指针指向下一个位置，准备再次写入")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('        int i = 0x7fffffff;\n        //用write方法每次只能写一个字节，如果要把i写进去就得写4次\n\t\traf.write(i >>> 24);//高8位\n\t\traf.write(i >>> 16);\n\t\traf.write(i >>> 8);\n\t\traf.write(i);\n        //或者用封装好的，源码其实也是上面的实现\n        //可以直接写一个int\n        raf.writeInt(i);\n        //写入带编码的字符串\n        String s="中";\n        byte utf[]=s.getBytes("UTF-8");\n        raf.write(utf);\n')])])]),e("p",[e("strong",[t._v("(4)读方法")]),t._v(" "),e("code",[t._v("int b = raf.read()")]),t._v("---\x3e读一个字节")]),t._v(" "),e("blockquote",[e("p",[t._v("注：要读出与写入一样的数据和类型，怎么写入的就怎么读,参考"),e("code",[t._v("(6)")])])]),t._v(" "),e("p",[e("strong",[t._v("(5)文件读写完成以后一定要关闭"),e("code",[t._v("raf.close()")])])]),t._v(" "),e("p",[e("strong",[t._v("(6)"),e("code",[t._v("序列化与基本类型序列化")])]),t._v("\n1）将"),e("strong",[t._v("类型int")]),t._v(" 转换成"),e("code",[t._v("4byte")]),t._v("或将"),e("strong",[t._v("其他数据类型")]),t._v("转换成"),e("code",[t._v("byte")]),t._v("的过程叫**"),e("code",[t._v("序列化")]),t._v("**")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("数据----\x3en byte\n")])])]),e("p",[t._v("2)"),e("strong",[e("code",[t._v("反序列化")])]),t._v("\n将"),e("code",[t._v("n个byte")]),t._v(" 转换成一个"),e("strong",[t._v("数据")]),t._v("的过程")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("nbyte ---\x3e 数据\n")])])]),e("p",[t._v("3)"),e("code",[t._v("RandomAccessFile")]),t._v("提供基本类型的读写方法，可以将"),e("code",[t._v("基本类型数据序列化到文件")]),t._v("或者将"),e("code",[t._v("文件内容反序列化为数据")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class RafSeriaTest {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tFile demo = new File("demo1");\n\t\tif(!demo.exists())demo.mkdir();\n\t\tFile file = new File(demo,"raf.dat");\n\t\tif(file.exists())\n\t\t\tfile.delete();\n\t\tif(!file.exists())\n\t\t\tfile.createNewFile();\n\t\t//打开文件，进行随机读写\n\t\tRandomAccessFile raf = new RandomAccessFile(file, "rw");\n\t\t/*序列化*/\n\t\tString s="helloworld";\n\t\tbyte buf[]=s.getBytes("UTF-8");\n\t\traf.write(buf);\n\t\tSystem.out.println(raf.getFilePointer());\n\t\tint i=454651234;\n\t\traf.writeInt(i);\n\t\tSystem.out.println(raf.getFilePointer());\n\t\t\n\t\t\n\t\t/*反序列化*/\n\t\traf.seek(0);\n\t\tbyte buf2[]=new byte[10];\n\t\traf.read(buf2);\n\t\tSystem.out.println(new String(buf2));\n\t\tint b=raf.readInt();\n\t\tSystem.out.println(b);\n\t\traf.close();\n\t}\n\n}\n/*\noutput:\n10\n14\nhelloworld\n1679497581\n*/\n')])])]),e("p",[t._v("遇到skipBytes函数，看下源码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("/**\n     * Attempts to skip over {@code n} bytes of input discarding the\n     * skipped bytes.\n     * 尝试跳过n个字节，然后通过seek去修改当前文件指针位置\n     *\n     * This method may skip over some smaller number of bytes, possibly zero.\n     * This may result from any of a number of conditions; reaching end of\n     * file before {@code n} bytes have been skipped is only one\n     * possibility. This method never throws an {@code EOFException}.\n     * The actual number of bytes skipped is returned.  If {@code n}\n     * is negative, no bytes are skipped.\n     *\n     * @param      n   the number of bytes to be skipped.\n     * @return     the actual number of bytes skipped.\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public int skipBytes(int n) throws IOException {\n        long pos;\n        long len;\n        long newpos;\n        //负数或0则不跳\n        if (n <= 0) {\n            return 0;\n        }\n        pos = getFilePointer();//当前文件指针位置\n        len = length();//naive方法，返回当前文件长度\n        newpos = pos + n;//新位置\n        //ex:pos=3,len=10,n=4 ->newpos=7 seek(7) return 4\n        //如果相加>len :pos=3,len=10,n=9 ->newpos=10 seek(10) return 7 no 9\n        if (newpos > len) {\n            newpos = len;\n        }\n        seek(newpos);\n\n        /* 返回实际跳过的字节数 */\n        return (int) (newpos - pos);\n    }\n")])])]),e("h2",{attrs:{id:"字节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字节流"}},[t._v("#")]),t._v(" "),e("strong",[e("code",[t._v("字节流")])])]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("InputStream、OutputStream")]),t._v("\nInputStream抽象了应用程序读取数据的方式\nOutputStream抽象了应用程序写出数据的方式")])]),t._v(" "),e("li",[e("p",[t._v("EOF = End   读到-1就读到结尾")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("输入流基本方法(读)")])]),t._v(" "),e("p",[t._v("int  b = in.read();读取一个字节无符号填充到int低八位.-1是 EOF\nin.read(byte[] buf) 将读入数据填充到buf字节数组\nin.read(byte[] buf,int start,int size)")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("输出流基本方法(写)")])]),t._v(" "),e("p",[t._v("out.write(int b)  写出一个byte到流，b的低8位\nout.write(byte[] buf)将buf字节数组都写入到流\nout.write(byte[] buf,int start,int size)")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("FileInputStream")]),t._v("---\x3e具体实现了在文件上读取数据")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('/*\n * 读取指定文件内容以16进制输出，每20byte换行\n * 注：单字节不适合读取大文件数据\n * */\npublic static void printHex(String fileName)throws IOException{\n\tFileInputStream in=new FileInputStream(fileName);\n\tint b;\n\tint index=1;\n\twhile((b=in.read())!=-1){\n\t\tif(b<=0xf){\n\t\t\t//只有低4位，前补0\n\t\t\tSystem.out.print(0);\n\t\t}\n\t\tSystem.out.print(Integer.toHexString(b)+" ");\n\t\tif(index++%20==0)System.out.println();\n\t}\n    in.close();\n}\n')])])]),e("p",[t._v("/**\n* 批量读取，对大文件而言效率高，也是我们最常用的读文件的方式\n* @param fileName\n* @throws IOException\n"),e("em",[t._v("/\npublic static void printHexByByteArray(String fileName)throws IOException{\nFileInputStream in=new FileInputStream(fileName);\nbyte buf[]=new byte[8")]),t._v('1024];//8kbytes的buf\nint index=1;\n/*从in中批量读取字节，放入到buf这个字节数组中，每个字节只存放低8位\n* 从第0个位置开始放，最多放buf.length个\n* 返回的是读到的字节的个数,or -1 如果没有更多的数据可以读取因为已经搜索到文件末尾(剩余数据大小<=buf.length)\n*/\nint bytes=0;//读取的字节个数\nwhile((bytes=in.read(buf,0,buf.length))!=-1){\nfor(int i=0;i<bytes;i++){\n//(buf[i]<=0xf&&buf[i]>=0x0)将0x0 ->0xf前补0 0xa0<0\n//或者用buf[i] & 0xff 判断\n//\t\t\t\tSystem.out.print(((buf[i]<=0xf&&buf[i]>=0x0)?"0"+Integer.toHexString(buf[i]):Integer.toHexString(buf[i] & 0xff) )+" ");//高位清0 避免错误\nSystem.out.print((((buf[i] & 0xff)<=0xf)?"0"+Integer.toHexString(buf[i]):Integer.toHexString(buf[i] & 0xff) )+" ");//高位清0 避免错误\nif(index++%20==0)System.out.println();\n}\n}\nin.close();\n}')])]),t._v(" "),e("li",[e("p",[e("code",[t._v("FileOutputStream")]),t._v(" 实现了向文件中写入byte数据的方法")]),t._v(" "),e("p",[t._v('public class FileOutputStreamTest {\npublic static void main(String[] args) throws IOException {\n//如果该文件不存在，则直接创建，如果存在，append为true则追加，false则删除后创建 (不指定 append 默认false删除后创建 )\n//FileOutputStream(String name, boolean append)\nFileOutputStream fos=new FileOutputStream("demo/out.dat");\nfos.write(\'A\');//只有write方法，只写低八位\n//写int同样需要写4次\nint a = 10;//write只能写八位,那么写一个int需要些4次每次8位\nfos.write(a >>> 24);\nfos.write(a >>> 16);\nfos.write(a >>> 8);\nfos.write(a);\nbyte[] gbk = "中国".getBytes("gbk");\nfos.write(gbk);\nfos.close();\nIOUtil.printHex("demo/out.dat");\n}\n}')])])]),t._v(" "),e("blockquote",[e("p",[t._v("综合上诉两个demo 做一个复制文件的demo")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('/**\n\t * 文件拷贝，字节批量读取\n\t * @param srcFile\n\t * @param destFile\n\t * @throws IOException\n\t */\n\tpublic static void copyFile(File srcFile,File destFile)throws IOException{\n\t\tif(!srcFile.exists()){\n\t\t\tthrow new IllegalArgumentException("文件:"+srcFile+"不存在");\n\t\t}\n\t\tif(!srcFile.isFile()){\n\t\t\tthrow new IllegalArgumentException(srcFile+"不是文件");\n\t\t}\n\t\tFileInputStream in = new FileInputStream(srcFile);\n\t\tFileOutputStream out = new FileOutputStream(destFile);\n\t\tbyte[] buf = new byte[8*1024];\n\t\tint b ;\n\t    while((b = in.read(buf,0,buf.length))!=-1){\n\t    \tout.write(buf,0,b);\n\t    \tout.flush();\n\t    }\n\t    in.close();\n\t    out.close();\n\t\t\n\t}\n')])])]),e("ol",{attrs:{start:"7"}},[e("li",[t._v("DataOutputStream/DataInputStream\n"),e("strong",[t._v('对"流"功能的扩展，可以更加方面的读取int,long，字符等类型数据')])])]),t._v(" "),e("blockquote",[e("p",[t._v("DataOutputStream")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  DataOutputStream dos = new DataOutputStream(new FileOutputStream(file));\n    \t\tdos.writeInt(10);\n    \t\tdos.writeInt(-10);\n    \t\tdos.writeLong(10l);\n    \t\tdos.writeDouble(10.5);\n    \t\t//采用utf-8编码写出\n    \t\tdos.writeUTF("中国");\n    \t\t//采用utf-16be编码写出\n    \t\tdos.writeChars("中国");\n    \t\tdos.close();\n')])])]),e("blockquote",[e("p",[t._v("DataInputStream")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("DataInputStream dis = new DataInputStream(\n\t\t\t   new FileInputStream(file));\n\t   int i = dis.readInt();\n\t   System.out.println(i);\n\t   i = dis.readInt();\n\t   System.out.println(i);\n\t   long l = dis.readLong();\n\t   System.out.println(l);\n\t   double d = dis.readDouble();\n\t   System.out.println(d);\n\t   String s = dis.readUTF();\n\t   System.out.println(s);\n\t   \n       dis.close();\n")])])]),e("ol",{attrs:{start:"8"}},[e("li",[e("strong",[e("code",[t._v("BufferedInputStream / BufferedOutputStream")])]),t._v("\n这两个流类位IO提供了带缓冲区的操作，一般打开文件进行写入\n或读取操作时，都会加上缓冲，"),e("strong",[t._v("这种流模式提高了IO的性能")]),t._v("\n从应用程序中把输入放入文件，相当于将一缸水倒入到另一个缸中:\n**FileOutputStream---\x3ewrite()**方法相当于一滴一滴地把水“转移”过去\n**DataOutputStream--\x3ewriteXxx()**方法会方便一些，相当于一瓢一瓢把水“转移”过去\n"),e("strong",[t._v("BufferedOutputStream---\x3ewrite")]),t._v("方法更方便，相当于一飘一瓢先放入桶中，再从桶中倒入到另一个缸中，性能提高了")])]),t._v(" "),e("p",[t._v("几个复制文件的demo")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('/**\n\t * 进行文件的拷贝，利用带缓冲的字节流\n\t * @param srcFile\n\t * @param destFile\n\t * @throws IOException\n\t */\n\tpublic static void copyFileByBuffer(File srcFile,File destFile)throws IOException{\n\t\tif(!srcFile.exists()){\n\t\t\tthrow new IllegalArgumentException("文件:"+srcFile+"不存在");\n\t\t}\n\t\tif(!srcFile.isFile()){\n\t\t\tthrow new IllegalArgumentException(srcFile+"不是文件");\n\t\t}\n\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\n\t\tBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));\n\t\tint a;\n\t\twhile((a=bis.read())!=-1){\n\t\t\tbos.write(a);\n\t\t\tbos.flush();//刷新缓冲区，否则写入不到文件\n\t\t}\n\t\tbis.close();\n\t\tbos.close();\n\t}\n\t/**\n\t * 进行文件的拷贝，利用带缓冲的字节流,以一定机制去刷新,而不是每次都去刷新\n\t * @param srcFile\n\t * @param destFile\n\t * @throws IOException\n\t */\n\tpublic static void copyFileByBuffer2(File srcFile,File destFile)throws IOException{\n\t\tif(!srcFile.exists()){\n\t\t\tthrow new IllegalArgumentException("文件:"+srcFile+"不存在");\n\t\t}\n\t\tif(!srcFile.isFile()){\n\t\t\tthrow new IllegalArgumentException(srcFile+"不是文件");\n\t\t}\n\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\n\t\tBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));\n\t\tint a;\n\t\tint index=0;\n\t\twhile((a=bis.read())!=-1){\n\t\t\t\n\t\t\tbos.write(a);\n\t\t\tif(index++%10==0)\n\t\t\tbos.flush();//刷新缓冲区，否则写入不到文件\n\t\t}\n\t\tbos.flush();\n\t\tbis.close();\n\t\tbos.close();\n\t}\n')])])]),e("p",[e("strong",[e("code",[t._v("复制文件总结")])])]),t._v(" "),e("ol",[e("li",[t._v("带buffer比不带buffer更快，每次都flush的话只快2-3倍左右")]),t._v(" "),e("li",[t._v("带buffer，一定次数再flush比每次都flush快的多，测试：10次再flush比每次flush快10倍左右")]),t._v(" "),e("li",[t._v("批量读取比单字节读取快的多，测试：buf[8*1024]比单字节快几千倍\n可以说最快的就是批量读取+一定次数再flush\n不过 对于大文件操作，直接利用加大批量读取即可，一定次数再flush可以说是多此一举了对于内存利用来说。")])]),t._v(" "),e("h2",{attrs:{id:"字符流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符流"}},[t._v("#")]),t._v(" "),e("strong",[e("code",[t._v("字符流")])])]),t._v(" "),e("ol",[e("li",[t._v("编码问题")]),t._v(" "),e("li",[t._v("认识文本和文本文件\njava的"),e("strong",[t._v("文本")]),t._v("(char)是16位无符号整数，unicode编码（双字节编码)\n"),e("strong",[t._v("文件")]),t._v("是byte byte byte ...的数据序列\n"),e("strong",[t._v("文本文件")]),t._v("是文本(char)序列按照某种编码方案(utf-8,utf-16be,gbk)序列化为byte的存储结果")]),t._v(" "),e("li",[e("strong",[t._v("字符流(Reader Writer)")]),t._v("----\x3e操作的是文本文件\n字符的处理，一次处理一个字符\n字符的底层仍然是基本的字节序列\n字符流的基本实现")])]),t._v(" "),e("blockquote",[e("p",[t._v("InputStreamReader   完成byte流解析为char流,按照编码解析\nOutputStreamWriter  提供char流到byte流，按照编码处理")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('   public class IsrAndOswDemo {\n\tpublic static void main(String[] args)throws IOException {\n\t\tFileInputStream in = new FileInputStream("e:\\\\javaio\\\\a.txt");\n\t\tInputStreamReader isr = new InputStreamReader(in,"utf-8");//默认是项目的编码,操作的时候，要写文件本身的编码格式\n\t\n\t\tFileOutputStream out = new FileOutputStream("e:\\\\javaio\\\\b.txt");\n\t\tOutputStreamWriter osw = new OutputStreamWriter(out,"utf-8");\n\t\t/*int c ;\n\t\twhile((c = isr.read())!=-1){\n\t\t\tSystem.out.print((char)c);\n\t\t}*/\n\t\tchar[] buffer = new char[8*1024];\n\t\tint c;\n\t\t/*批量读取，放入buffer这个字符数组，从第0个位置开始放置，最多放buffer.length个\n\t\t  返回的是读到的字符的个数\n\t\t*/\n\t\twhile(( c = isr.read(buffer,0,buffer.length))!=-1){\n\t\t\tString s = new String(buffer,0,c);\n\t\t\tSystem.out.print(s);\n\t\t\tosw.write(buffer,0,c);\n\t\t\tosw.flush();\n\t\t}\n\t\tisr.close();\n\t\tosw.close();\n\t\t\n\t}\n\n}\n')])])]),e("ol",{attrs:{start:"4"}},[e("li",[e("strong",[t._v("FileReader/FileWriter")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class FrAndFwDemo {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//不存在则创建，存在非追加则删除重建\n\t\tFileReader fr = new FileReader("demo\\\\file.txt");\n\t\tFileWriter fw = new FileWriter("demo\\\\file2.txt");\n\t\tchar[] buf=new char[1024];\n\t\tint c;\n\t\twhile((c=fr.read(buf,0,buf.length))!=-1){\n\t\t\tfw.write(buf,0,c);\n\t\t\tfw.flush();\n\t\t}\n\t\tfr.close();\n\t\tfw.close();\n\t}\n}\n')])])]),e("p",[t._v("**"),e("code",[t._v("存在的问题")]),t._v("：**FileReader/FileWriter 构造函数没有指定编码格式。\n如项目编码是UTF-8,file.txt是gbk,则file2.txt编码与项目编码一致，故会产生乱码。\n**解决方法：**用InputStreamReader / OutputStreamReader     或者 操作文件编码与项目编码一致")]),t._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[e("p",[e("strong",[t._v("字符流的过滤器")]),t._v("\nBufferedReader   ----\x3ereadLine 一次读一行\nBufferedWriter/PrintWriter   ----\x3e写一行")]),t._v(" "),e("p",[t._v('public class BrAndBwOrPwDemo {\npublic static void main(String[] args) throws IOException {\n//对文件进行读写操作\nBufferedReader br=new BufferedReader(\nnew InputStreamReader(\nnew FileInputStream("demo\\file.txt")));\nBufferedWriter bw=new BufferedWriter(\nnew OutputStreamWriter(\nnew FileOutputStream("demo\\file3.txt")));\nString line="";\nwhile((line=br.readLine())!=null){\nSystem.out.println(line);//一次读一行，不带换行，手动加上\nbw.write(line);\nbw.newLine();//写入一个\'\\n\'\nbw.flush();\n}\nbr.close();\nbw.close();\n}\n}')])])]),t._v(" "),e("p",[t._v("若改使用PrintWriter会更方便")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public void usePrint() throws IOException {\n\t\t// 对文件进行读写操作\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(\n\t\t\t\tnew FileInputStream("demo\\\\file.txt")));\n\t\tPrintWriter pw=new PrintWriter("demo\\\\file4.txt");\n\t\tString line = "";\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tSystem.out.println(line);// 一次读一行，不带换行，手动加上\n\t\t\t//pw还有append,format,write,print等函数\n\t\t\tpw.println(line);\n\t\t\tpw.flush();\n\t\t}\n\t\tbr.close();\n\t\tpw.close();\n\t}\n')])])]),e("h2",{attrs:{id:"对象的序列化-反序列化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的序列化-反序列化"}},[t._v("#")]),t._v(" "),e("strong",[e("code",[t._v("对象的序列化，反序列化")])])]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("对象序列化，就是将Object转换成byte序列，反之叫对象的反序列化")])]),t._v(" "),e("li",[e("code",[t._v("序列化流(ObjectOutputStream)")]),t._v(",是过滤流----writeObject\n"),e("code",[t._v("反序列化流(ObjectInputStream)")]),t._v("---readObject")])]),t._v(" "),e("blockquote",[e("p",[t._v("主要是读写对象，当然extends OutputStream所以OutputStream的基本方法也可以使用")])]),t._v(" "),e("blockquote",[e("p",[t._v("Student.class")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class Student implements Serializable{\n\tprivate String stuno;\n\tprivate String stuname;\n\tprivate int stuage;  \npublic Student(String stuno, String stuname, int stuage) {\n\t\tsuper();\n\t\tthis.stuno = stuno;\n\t\tthis.stuname = stuname;\n\t\tthis.stuage = stuage;\n\t}\n@Override\npublic String toString() {\n\treturn "Student [stuno=" + stuno + ", stuname=" + stuname + ", stuage="\n\t\t\t+ stuage + "]";\n}\n}\n')])])]),e("blockquote",[e("p",[t._v("序列化和反序列化")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class ObjectSeriaDemo1 {\n\tpublic static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {\n\t\tString file="demo/obj.dat";\n\t\t//序列化\n\t\tObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(file));\n\t\tStudent stu=new Student("1", "gahingZ", 21);\n\t\toos.writeObject(stu);\n\t\toos.flush();\n\t\toos.close();\n\t\t//反序列化\n\t\tObjectInputStream ois=new ObjectInputStream(new FileInputStream(file));\n\t\tStudent mStu=(Student) ois.readObject();\n\t\tSystem.out.println(mStu.toString());\n\t}\n}\noutput:\nStudent [stuno=1, stuname=gahingZ, stuage=21]\n')])])]),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[e("strong",[t._v("序列化接口(Serializable)")]),t._v("\n对象必须实现序列化接口 ，才能进行序列化，否则将出现异常\n这个接口，没有任何方法，只是一个标准")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("transient关键字")])]),t._v(" "),e("p",[t._v("//该元素不会进行jvm默认的序列化\n//Student类不想让stuage序列化\nprivate transient int stuage;")])])]),t._v(" "),e("blockquote",[e("p",[t._v("再次运行ObjectSeriaDemo1")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   output:\n    Student [stuno=1, stuname=gahingZ, stuage=0]\n")])])]),e("blockquote",[e("p",[t._v("0是int的默认值，用这种方式就可以简单的让某些元素不被序列化")])]),t._v(" "),e("p",[e("em",[e("strong",[t._v("分析ArrayList源码中序列化和反序列化的问题")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("transient Object[] elementData; // non-private to simplify nested class access\n//该元素是已开辟的数组，存入的数据长度一般是不满的，so不需要进行序列化 用transient 修饰,否则整个都序列化性能太差，eq:开辟了10000的数组 却只存了1个元素\n\n如果要手动序列化，则Studnt类加入以下方法\n\n private void writeObject(java.io.ObjectOutputStream s)\n\t\t        throws java.io.IOException{\n\t\t s.defaultWriteObject();//把jvm能默认序列化的元素进行序列化操作\n\t\t s.writeInt(stuage);//自己完成stuage的序列化\n\t }\n\t private void readObject(java.io.ObjectInputStream s)\n\t\t        throws java.io.IOException, ClassNotFoundException{\n\t\t  s.defaultReadObject();//把jvm能默认反序列化的元素进行反序列化操作\n\t\t  this.stuage = s.readInt();//自己完成stuage的反序列化操作\n\t}\n")])])]),e("blockquote",[e("p",[t._v("再次运行ObjectSeriaDemo1")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   output:\n    Student [stuno=1, stuname=gahingZ, stuage=21]\n")])])]),e("p",[t._v("当然上面这样写没有什么意义(要序列化呢还是不序列化呢)，\n所以一般要写writeObject方法的都是数组元素非整个序列化，序列化的个数是动态的。\n那么，让我们分析ArrayList中的写法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException{\n        // Write out element count, and any hidden stuff\n        int expectedModCount = modCount;\n        s.defaultWriteObject();//默认的都序列化了\n\n        // Write out size as capacity for behavioural compatibility with clone()\n        s.writeInt(size);\n\n        // elementData只放了size个 所以就只序列化size个 而不是elementData.length\n        for (int i=0; i<size; i++) {\n            s.writeObject(elementData[i]);\n        }\n        //并发操作异常\n        if (modCount != expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n    }\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("序列化中 "),e("strong",[t._v("子类和父类构造函数的调用问题")])])]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("一个类实现了序列化接口，其子类都可以序列化")]),t._v(" "),e("strong",[t._v("子类在反序列化时，从最顶级父类开始往下找(递归)，若父类实现了序列化接口，则不会递归调用其构造函数，否则其父类的构造函数会被调用")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('package com.france;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nclass Bar{\n\tBar(){\n\t\tSystem.out.println("Bar..");\n\t}\n}\nclass Bar1 extends Bar{\n\tBar1(){\n\t\tSystem.out.println("Bar1..");\n\t}\n}\nclass Bar2 extends Bar1 implements Serializable{\n\tpublic Bar2(){\n\t\tSystem.out.println("Bar2..");\n\t}\n}\nclass Bar3 extends Bar2{\n\tpublic Bar3(){\n\t\tSystem.out.println("Bar3..");\n\t}\n}\nclass Bar4 extends Bar3{\n\tpublic Bar4(){\n\t\tSystem.out.println("Bar4..");\n\t}\n}\npublic class ObjectSeriaDemo2 {\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException, ClassNotFoundException, IOException {\n\t\ttest1();\n\t\ttest2();\n\t}\n\tstatic void test1()throws FileNotFoundException, IOException, ClassNotFoundException {\n\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\tnew FileOutputStream("demo/obj1.dat"));\n\t\tBar2 bar2=new Bar2();\n\t\toos.writeObject(bar2);\n\t\tSystem.out.println("---------");\n\t\toos.flush();\n\t\toos.close();\n\t\t\n\t\tObjectInputStream ois = new ObjectInputStream(\n\t\t\t\tnew FileInputStream("demo/obj1.dat"));\n\t\tBar2 mBar2=(Bar2) ois.readObject();\n\t\tSystem.out.println(mBar2);\n\t\tois.close();\n\t\tSystem.out.println("---------");\n\t}\n\tstatic void test2()throws FileNotFoundException, IOException, ClassNotFoundException {\n\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\tnew FileOutputStream("demo/obj2.dat"));\n\t\tBar4 bar4=new Bar4();\n\t\toos.writeObject(bar4);\n\t\tSystem.out.println("---------");\n\t\toos.flush();\n\t\toos.close();\n\t\t\n\t\tObjectInputStream ois = new ObjectInputStream(\n\t\t\t\tnew FileInputStream("demo/obj2.dat"));\n\t\tBar4 mBar4=(Bar4) ois.readObject();\n\t\tSystem.out.println(mBar4);\n\t\tois.close();\n\t\tSystem.out.println("---------");\n\t}\n}\n')])])]),e("blockquote"),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("output:\nBar..\nBar1..\nBar2..\n---------\nBar..\nBar1..\ncom.france.Bar2@3d4eac69\n---------\nBar..\nBar1..\nBar2..\nBar3..\nBar4..\n---------\nBar..\nBar1..\ncom.france.Bar4@1b6d3586\n---------\n")])])]),e("p",[t._v("即[Bar、Bar1不可序列化] Bar2实现序列化接口 并且 Bar3/Bar4都可序列化")]),t._v(" "),e("p",[t._v("可序列化的子类 2-4 在"),e("code",[t._v("进行反序列化时，会递归调用 不可序列化父类的构造函数")])])])}),[],!1,null,null,null);e.default=r.exports}}]);