(window.webpackJsonp=window.webpackJsonp||[]).push([[371],{1157:function(e,r,v){"use strict";v.r(r);var _=v(30),i=Object(_.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("blockquote",[r("p",[e._v("Ref:http://blog.csdn.net/universus/article/details/6211589")])]),e._v(" "),r("h2",{attrs:{id:"出现binder的原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#出现binder的原因"}},[e._v("#")]),e._v(" "),r("strong",[e._v("出现Binder的原因：")])]),e._v(" "),r("p",[e._v("Android平台开发主要基于Client-Server")]),e._v(" "),r("ul",[r("li",[e._v("系统复杂性：\n"),r("ul",[r("li",[e._v("Linux实践中学到，IPC 中的管道/信号量/共享内存 只有通过一定的封装才能支持Client-Server通信,增加系统复杂性")])])]),e._v(" "),r("li",[e._v("传输效率：\n"),r("ul",[r("li",[e._v("支持Client-Server的"),r("code",[e._v("socket通信")]),e._v("主要用于跨网络的进程间通信or本机上进程间的低速通信，传输效率低，开销大")]),e._v(" "),r("li",[r("code",[e._v("消息队列")]),e._v("和"),r("code",[e._v("管道")]),e._v("采用存储-转发方式，即数据先从"),r("code",[e._v("发送方缓存区")]),e._v("拷贝到"),r("code",[e._v("内核开辟的缓存区")]),e._v("中，然后再从"),r("code",[e._v("内核缓存区")]),e._v("拷贝到"),r("code",[e._v("接收方缓存区")]),e._v("，至少有两次拷贝过程**(数据拷贝2次)"),r("strong",[e._v("。"),r("code",[e._v("共享内存")]),e._v("虽然无需拷贝，但控制复杂，难以使用")]),e._v("(数据拷贝0次)**")]),e._v(" "),r("li",[e._v("Binder**(数据拷贝1次)**")])])]),e._v(" "),r("li",[e._v("安全性：\n"),r("ul",[r("li",[e._v("传统IPC接收方(比如系统服务)无法确保进程的UID/PID正确性，完全依赖上层协议来确保安全性")]),e._v(" "),r("li",[e._v("使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。")]),e._v(" "),r("li",[e._v("传统IPC访问接入点是开放的，无法建立私有通道。无法阻止恶意程序通过猜测接收方地址获得连接。")]),e._v(" "),r("li",[e._v("Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送方添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。")])])])]),e._v(" "),r("h2",{attrs:{id:"binder介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binder介绍"}},[e._v("#")]),e._v(" Binder介绍")]),e._v(" "),r("ul",[r("li",[e._v("Binder提供server的访问接口，client想要访问该接口需要通过Binder建立的管道接口")]),e._v(" "),r("li",[e._v("面向对象：server中的对象，提供访问server请求的函数。Client通过Binder指针(Binder存在于远端Server,但在内存中被引用)调用方法访问server.")]),e._v(" "),r("li",[e._v("通过上述方法，将进程间通信转为对某个Binder的引用，Binder跨进程，实体位于一个进程，引用却遍布系统各个进程。")])]),e._v(" "),r("h2",{attrs:{id:"binder通信模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binder通信模型"}},[e._v("#")]),e._v(" Binder通信模型")]),e._v(" "),r("hr"),e._v(" "),r("p",[e._v("未完待续")]),e._v(" "),r("hr")])}),[],!1,null,null,null);r.default=i.exports}}]);