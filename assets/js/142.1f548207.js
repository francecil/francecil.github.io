(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{921:function(t,v,_){"use strict";_.r(v);var r=_(30),a=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("Fiber 架构想解决的是 React 的虚拟 DOM 树在构建和 DIFF 阶段无法打断的问题。")]),t._v(" "),v("p",[t._v("具体的实现方式有：")]),t._v(" "),v("ol",[v("li",[t._v("双缓冲机制：保留上一次状态和处理中的 Fiber 树。难点在于中断和恢复机制。")]),t._v(" "),v("li",[t._v("两阶段提交：虚拟 DOM 树构建可打断，提交变更不可打断")]),t._v(" "),v("li",[t._v("闲时调度：每一个 Fiber 节点都是一个最小执行单元")])]),t._v(" "),v("h2",{attrs:{id:"草稿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#草稿"}},[t._v("#")]),t._v(" 草稿")]),t._v(" "),v("p",[t._v("中断的执行单元? 不是单元内暂停，而是已经执行完了，准备执行下一个执行单元时中断。")]),t._v(" "),v("p",[t._v("每个虚拟dom是一个fiber单元，构成链表")]),t._v(" "),v("p",[t._v("fiber 遍历，为啥采用迭代代替递归？\n需从头恢复，不能随意中断")]),t._v(" "),v("p",[t._v("componentWillMount 这些方法为什么不能用？\n如果执行了副作用，会调用多次，")]),t._v(" "),v("p",[t._v("setState 执行 fiber 链后，")]),t._v(" "),v("p",[t._v("高优任务，放弃原链。")]),t._v(" "),v("h2",{attrs:{id:"两个阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两个阶段"}},[t._v("#")]),t._v(" 两个阶段")]),t._v(" "),v("h2",{attrs:{id:"简单说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简单说明"}},[t._v("#")]),t._v(" 简单说明")]),t._v(" "),v("p",[t._v("协调(diff,非连续)，提交")]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ol",[v("li",[t._v("双缓冲机制：2 个 Fiber 树，其中一个为 WIP ，用于处理进行中的 DIFF，并保持和原始 Fiber 树的差异。后续提交阶段直接应用差异更新真实 DOM")]),t._v(" "),v("li",[t._v("中断和恢复：待研究。。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);