(window.webpackJsonp=window.webpackJsonp||[]).push([[383],{1281:function(e,t,n){"use strict";n.r(t);var r=n(30),i=Object(r.a)({},(function(){var e=this._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("p",[this._v("今天偶然看到BigInteger里面有一些有意思的函数。特意看了下源码")]),this._v(" "),e("p",[this._v("当前大数后的第一个素数")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[this._v('/**\n    * 返回的这个数不是素数的可能性为2^-100.但不会跳过任何一个素数\n    *\n    * @return the first integer greater than this {@code BigInteger} that\n    *         is probably prime.\n    * @throws ArithmeticException {@code this < 0} or {@code this} is too large.\n    * @since 1.5\n    */\n    public BigInteger nextProbablePrime() {\n        if (this.signum < 0)\n            throw new ArithmeticException("start < 0: " + this);\n\n        // Handle trivial cases\n        if ((this.signum == 0) || this.equals(ONE))\n            return TWO;\n\n        BigInteger result = this.add(ONE);\n\n        // Fastpath for small numbers\n        if (result.bitLength() < SMALL_PRIME_THRESHOLD) {\n\n            // Ensure an odd number\n            if (!result.testBit(0))\n                result = result.add(ONE);\n\n            while (true) {\n                // Do cheap "pre-test" if applicable\n                if (result.bitLength() > 6) {\n                    long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();\n                    if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||\n                        (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||\n                        (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {\n                        result = result.add(TWO);\n                        continue; // Candidate is composite; try another\n                    }\n                }\n\n                // All candidates of bitLength 2 and 3 are prime by this point\n                if (result.bitLength() < 4)\n                    return result;\n\n                // The expensive test\n                if (result.primeToCertainty(DEFAULT_PRIME_CERTAINTY, null))\n                    return result;\n\n                result = result.add(TWO);\n            }\n        }\n\n        // Start at previous even number\n        if (result.testBit(0))\n            result = result.subtract(ONE);\n\n        // Looking for the next large prime\n        int searchLen = getPrimeSearchLen(result.bitLength());\n\n        while (true) {\n           BitSieve searchSieve = new BitSieve(result, searchLen);\n           BigInteger candidate = searchSieve.retrieve(result,\n                                                 DEFAULT_PRIME_CERTAINTY, null);\n           if (candidate != null)\n               return candidate;\n           result = result.add(BigInteger.valueOf(2 * searchLen));\n        }\n    }')])])])])}),[],!1,null,null,null);t.default=i.exports}}]);