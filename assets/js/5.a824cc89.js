(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{1010:function(t,e,r){"use strict";r.r(e);var _=r(30),v=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("之前写了一篇文章 《"),e("a",{attrs:{href:"https://juejin.cn/post/7249665163242307640",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何实现 H5 秒开？"),e("OutboundLink")],1),t._v("》 ，聊到了如何根据"),e("strong",[t._v("分类思维")]),t._v("来梳理性能优化方案，反响还不错。")]),t._v(" "),e("p",[t._v("于是，我计划输出"),e("a",{attrs:{href:"https://juejin.cn/column/7266984374846259239",target:"_blank",rel:"noopener noreferrer"}},[t._v("「前端首屏优化」专栏系列"),e("OutboundLink")],1),t._v("，从不同角度聊聊首屏优化实践，包括且不限于防劣化、工程体系、端能力等，欢迎关注 ✨✨。")]),t._v(" "),e("p",[t._v("作为专栏的第一篇，本文将从客户端角度，聊聊如何借助"),e("strong",[t._v("端能力")]),t._v("优化前端首屏加载速度。除了方案介绍，本文还会提供数据收益、注意事项、开发成本等，以帮助大家更好的评估实现优先级，选择适合业务的方案。")]),t._v(" "),e("h1",{attrs:{id:"本文适合哪些读者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本文适合哪些读者"}},[t._v("#")]),t._v(" 本文适合哪些读者")]),t._v(" "),e("p",[t._v("本文主要是经验和原理之谈，不涉及客户端代码实现，比较适合想开拓视野的"),e("strong",[t._v("前端领域读者")]),t._v("。")]),t._v(" "),e("h1",{attrs:{id:"整体方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整体方案"}},[t._v("#")]),t._v(" 整体方案")]),t._v(" "),e("p",[e("img",{attrs:{src:r(755),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("上图为通用的"),e("strong",[t._v("页面加载链路，")]),t._v(" 利用分类思维，对该流程进行"),e("strong",[t._v("简化、前置、拆分")]),t._v("，得到如下客户端优化方案：")]),t._v(" "),e("p",[e("img",{attrs:{src:r(756),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("以上是 8 种常见的优化手段，实际项目中不一定都用上，并且优化手段也不止这些。")]),t._v(" "),e("p",[t._v("下面，我将进一步介绍这些方案。")]),t._v(" "),e("h1",{attrs:{id:"一、容器启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、容器启动"}},[t._v("#")]),t._v(" 一、容器启动")]),t._v(" "),e("p",[t._v("与浏览器不同，App 打开 H5 页面的第一步并不是建立页面请求连接，而是"),e("strong",[t._v("初始化 Webview")]),t._v("。")]),t._v(" "),e("p",[t._v("初始化 Webview 包括创建 Webview 实例，对于 App 冷启后的首次 Webview 初始化，还需要初始化浏览器内核。")]),t._v(" "),e("p",[t._v("因此，对于冷启或者全新安装的 App ，首次初始化 Webview 耗时相对较长，大概在"),e("strong",[t._v("数百")]),t._v(" "),e("strong",[t._v("ms")]),t._v(" ；而二次打开就较快了，大概在"),e("strong",[t._v("数十 ms")]),t._v("。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("首次打开 Webview 耗时")]),t._v(" "),e("th",[t._v("二次打开 Webview 耗时")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("数百ms")]),t._v(" "),e("td",[t._v("数十ms")])])])]),t._v(" "),e("blockquote",[e("p",[t._v("PS：具体数据与用户设备有关，经验值大致如上")])]),t._v(" "),e("p",[t._v("容器启动优化的目标就是"),e("strong",[t._v("将初始化的这段时间省去")]),t._v("，常用的解决方案是"),e("strong",[t._v("容器预建")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"_1️⃣-容器预建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-容器预建"}},[t._v("#")]),t._v(" 1️⃣ 容器预建")]),t._v(" "),e("p",[t._v("提前创建 Webview 容器，当需要加载页面的时候就可以直接使用，省去容器初始化时间（数十ms~数百ms）。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(757),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("提前创建 Webview 容器，需要注意"),e("strong",[t._v("创建时机")]),t._v("和"),e("strong",[t._v("创建个数")]),t._v("。")]),t._v(" "),e("ul",[e("li",[t._v("创建时机：闲时创建。Webview 只能在主线程创建，但又不能阻碍主流程，因此需要在 IdleHandler 时机处理。与前端的 requestIdleCallback 、React Scheduler 概念相似。")]),t._v(" "),e("li",[t._v("创建个数：一般仅创建一个，当预创建的 Webview 容器被使用后，再重新预创建（考虑内存状态）。")])]),t._v(" "),e("p",[t._v("此外，结合线程池的概念，可以对容器进行"),e("strong",[t._v("复用")]),t._v("，页面销毁并不回收 Webview 容器，而是继续常驻（考虑内存状态）。")]),t._v(" "),e("h1",{attrs:{id:"二、资源加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、资源加载"}},[t._v("#")]),t._v(" 二、资源加载")]),t._v(" "),e("p",[t._v("容器启动后，客户端将发起页面请求并加载资源。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(758),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("根据页面的复杂度，这一阶段耗时大概在几十毫秒到数秒之间。")]),t._v(" "),e("p",[t._v("常用的优化手段包括：")]),t._v(" "),e("ol",[e("li",[t._v("网络建连优化：优化网络连接，让解析更快、链路更短")]),t._v(" "),e("li",[t._v("资源离线化：使用本地资源，直接省去网络请求")]),t._v(" "),e("li",[t._v("资源分级下发：根据机型信息差异化分发离线包，减少包体积")]),t._v(" "),e("li",[t._v("资源预加载：在当前页面空闲状态加载下一页面资源")])]),t._v(" "),e("h2",{attrs:{id:"_2️⃣-网络建连优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-网络建连优化"}},[t._v("#")]),t._v(" 2️⃣ 网络建连优化")]),t._v(" "),e("p",[t._v("利用 DNS 预解析以及 DNS 缓存，让请求解析更快。")]),t._v(" "),e("p",[t._v("利用 CDN、域名智能调度等方案，自动选择链路较短的服务。")]),t._v(" "),e("p",[t._v("根据经验，这块的优化能够节省数十 ms 到数百 ms 不等。")]),t._v(" "),e("p",[t._v("另外，网络建连优化并不单针对 H5 处理，而是对整个客户端请求都有收益，但需要有相应的基建配合。")]),t._v(" "),e("h2",{attrs:{id:"_3️⃣-资源离线化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-资源离线化"}},[t._v("#")]),t._v(" 3️⃣ 资源离线化")]),t._v(" "),e("p",[t._v("资源离线化，即将 H5 资源提前下载（或内置）到 App 中。这样加载资源时就可以通过 App 内部的请求拦截机制转发本地资源，避免网络请求。")]),t._v(" "),e("p",[t._v("优化后，可以显著降低 "),e("strong",[t._v("「资源加载」")]),t._v(" 这个环节的耗时，减少白屏时间，一般不超过 100ms（仅剩资源解析和本地 I/O 耗时），不再受弱网限制。")]),t._v(" "),e("p",[t._v("不过，要实施一整套完整的离线化方案，需要考虑的点较多：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("更新策略：")]),t._v(" 紧急更新、轮询更新、冷启更新")]),t._v(" "),e("li",[e("strong",[t._v("动态差分：")]),t._v(" bsdiff 算法，获取不同版本离线包的差异")]),t._v(" "),e("li",[e("strong",[t._v("签名校验：")]),t._v(" 校验资源是否被篡改")]),t._v(" "),e("li",[e("strong",[t._v("在线")]),t._v(" "),e("strong",[t._v("CDN")]),t._v("：离线资源未找到的情况下使用 CDN 资源兜底")]),t._v(" "),e("li",[t._v("...")])]),t._v(" "),e("p",[t._v("网上找了一个"),e("a",{attrs:{href:"https://github.com/mcuking/blog/issues/63",target:"_blank",rel:"noopener noreferrer"}},[t._v("开源方案"),e("OutboundLink")],1),t._v("，可供学习使用。")]),t._v(" "),e("p",[t._v("此外，还需注意 「HTML 是否应该放入离线包」的问题，是选择更好的性能还是更好的更新速度。")]),t._v(" "),e("blockquote",[e("p",[t._v("关于这方面的考量以及优化策略，我写了一篇 "),e("a",{attrs:{href:"https://juejin.cn/post/7254549436625256506",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTML 放入离线包?你需要了解的离线策略 - 掘金"),e("OutboundLink")],1),t._v("，推荐阅读")])]),t._v(" "),e("h2",{attrs:{id:"_4️⃣-资源分级下发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-资源分级下发"}},[t._v("#")]),t._v(" 4️⃣ 资源分级下发")]),t._v(" "),e("p",[t._v("分级下发指的是根据用户设备信息（机型、系统等）下发不同的资源包，尽可能减少资源请求大小。即可以作用于离线包，也可以作用于在线 CDN（边缘计算）。根据业务经验，"),e("strong",[t._v("每减小 100 KB 体积，约带来 50 ms 的收益。")])]),t._v(" "),e("p",[t._v("要实现资源分级下发，往往还需要"),e("strong",[t._v("前端打包配合改造")]),t._v("。")]),t._v(" "),e("p",[t._v("举个例子：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("静态资源分级")]),t._v("：相对低端的机型，内存以及分辨率并不高，那么页面中的图片就没有必要使用三倍图了。在前端打包的时候，对图片进行不同等级的分级压缩（参考 "),e("a",{attrs:{href:"https://github.com/lovell/sharp",target:"_blank",rel:"noopener noreferrer"}},[t._v("sharp"),e("OutboundLink")],1),t._v(" 工具），得到多种版本产物。")]),t._v(" "),e("li",[e("strong",[t._v("业务代码分级")]),t._v("：除了资源外，还有一种极致优化，如果业务针对操作系统做了较多的适配代码，那么可以在打包的时候，编写打包插件，抽分得到两份不含系统兼容逻辑的产物。")])]),t._v(" "),e("p",[t._v("根据系统版本获取相应系统的资源，这个好理解。但是机型这个怎么评估中高低端？")]),t._v(" "),e("p",[t._v("其实也很简单，"),e("strong",[t._v("建立机型库，维护机型评分")]),t._v("。不同业务可以根据评分、系统版本等设定自己的中高低端机型范围。")]),t._v(" "),e("blockquote",[e("p",[t._v("针对某些机型的特殊情况，还可以建立一套白名单和黑名单机制。")])]),t._v(" "),e("p",[t._v("这样，在客户端发起离线包资源请求的时候，带上机型信息，离线包平台/ CDN 服务就可以计算得到合适的资源包了。")]),t._v(" "),e("p",[t._v("需要注意的是，随着网络速度逐渐变快，该方案的性能收益越来越小。")]),t._v(" "),e("p",[t._v("但除了性能收益外，分级下发还有两个优势：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("节省带宽")]),t._v("：离线包下发用到的带宽也是要钱的")]),t._v(" "),e("li",[e("strong",[t._v("优化内存")]),t._v("：中低端机使用较小的图片，可以避免内存溢出。")])]),t._v(" "),e("h2",{attrs:{id:"_5️⃣-资源预加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-资源预加载"}},[t._v("#")]),t._v(" 5️⃣ 资源预加载")]),t._v(" "),e("p",[t._v("资源预加载指的是，在当前页面提前缓存下一个页面的资源。")]),t._v(" "),e("p",[t._v("在浏览器上，我们可以使用 "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Prefetch",target:"_blank",rel:"noopener noreferrer"}},[t._v("Prefetch"),e("OutboundLink")],1),t._v(" 实现这个效果，浏览器会在"),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Prefetch#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%9A%84%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("空闲时间"),e("OutboundLink")],1),t._v("下载指定的资源。")]),t._v(" "),e("div",{staticClass:"language-html line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("rel")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("prefetch"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("href")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("/images/big.jpeg"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("该方案针对多页面有效。但在移动端上，我们通常不会选择 MPA （多页面），而是打开多个 Webview ，或者原生和 Webview 互相跳转。")]),t._v(" "),e("p",[t._v("因此，"),e("strong",[t._v("要想实现资源预加载，就得借助客户端能力：")]),t._v(" 在上一个页面（原生或者 Webview）调用 JSB ，传递需要预加载的资源地址，由客户端内部进行请求和缓存。")]),t._v(" "),e("p",[t._v("在实现细节上，还要做到请求复用。即在资源请求过程中，若发生页面跳转，则继续未完成的目标请求而不是重新创建。")]),t._v(" "),e("blockquote",[e("p",[t._v("你看，这像不像一道面试题 —— 「使用 Promise 实现请求复用」")])]),t._v(" "),e("p",[t._v("此外，要实施"),e("strong",[t._v("资源")]),t._v(" "),e("strong",[t._v("预加载")]),t._v("还需要关注 3 个事：")]),t._v(" "),e("ul",[e("li",[t._v("预加载时机：需要在空闲状态进行，避免和主逻辑竞争资源。")]),t._v(" "),e("li",[t._v("预加载内容：一般由服务端下发，涉及三端配合（移动端、前端、服务端）。")]),t._v(" "),e("li",[t._v("转换率收益：预加载会带来更高的资源带宽成本。如果前置页面到目标页面转化率只有 10%，那么请求数量会放大 10 倍，造成带宽成本浪费。")])]),t._v(" "),e("p",[t._v("基于以上原因，资源预加载的使用场景往往有限，不是所有页面都适用。")]),t._v(" "),e("h1",{attrs:{id:"三、代码执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、代码执行"}},[t._v("#")]),t._v(" 三、代码执行")]),t._v(" "),e("p",[t._v("相比原生页面的提前编译/静态编译（AOT），JS 的动态编译（JIT）性能相对较差。在低端机上，这个差异更为明显。")]),t._v(" "),e("p",[t._v("因此，若要优化代码执行效率，有一个解决方案是 JS 代码 AOT 化。"),e("strong",[t._v("个人水平有限")]),t._v("，不敢多说，提供两篇文章供拓展学习：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/572447953",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript/JavaScript低成本静态编译AOT的探索"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://developer.aliyun.com/article/883407",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8 JS AOT化的探索与实践"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("此外，由于业务的动态性，不可能所有 JS 代码都走静态编译。")]),t._v(" "),e("p",[t._v("一个思路是，采用原生渲染或自绘制，首屏代码走 AOT，基于原生能力执行；后续业务逻辑代码走 JIT ，基于 JS Runtime 执行；两者通过 JSBridge 通信。")]),t._v(" "),e("p",[t._v("要完成这套工作，需要开发构建工具、渲染引擎等一系列套件，事实上已经脱离纯前端生态，因此，我并不打算将其列为前端首屏优化手段。")]),t._v(" "),e("p",[t._v("各大厂应该也有类似的框架，比如字节的 Lynx ，这里有一篇介绍文章："),e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1916784",target:"_blank",rel:"noopener noreferrer"}},[t._v("Lynx：来自字节跳动的高性能跨端框架"),e("OutboundLink")],1),t._v("。从个人使用经验上看，对首屏性能提升确实蛮大的，结合其他优化方案基本能做到"),e("strong",[t._v("首屏直出")]),t._v("，与原生无异。")]),t._v(" "),e("h1",{attrs:{id:"四、数据获取"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、数据获取"}},[t._v("#")]),t._v(" 四、数据获取")]),t._v(" "),e("p",[t._v("前面环节执行完毕，此时已经得到一个骨架页面，待数据填充。")]),t._v(" "),e("p",[t._v("接下来就是数据获取部分，页面数据通过主接口获取，耗时在"),e("strong",[t._v("数百毫秒到数秒")]),t._v("不等，和数据量、网络、服务链路有关。")]),t._v(" "),e("p",[t._v("要对这个环节进行优化，通常有两种手段：")]),t._v(" "),e("ul",[e("li",[t._v("数据预取：提前获取")]),t._v(" "),e("li",[t._v("数据缓存：优先使用旧数据")])]),t._v(" "),e("h2",{attrs:{id:"_6️⃣-数据预取"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-数据预取"}},[t._v("#")]),t._v(" 6️⃣ 数据预取")]),t._v(" "),e("p",[t._v("数据预取指的是将数据获取时机前置，通常是与 Webview 初始化并行，并由客户端发起数据请求。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(759),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("优化后，原来的数据获取阶段不再额外发起请求，而是复用客户端请求结果。如果请求还未拿到结果，则继续等待。")]),t._v(" "),e("blockquote",[e("p",[t._v("实际上前端无需额外处理，正常前端发起的请求也是走的 JSBridge ，统一由客户端在内部处理即可。")])]),t._v(" "),e("p",[t._v("那客户端如何知晓请求参数？业界常用方案有以下三种：")]),t._v(" "),e("ul",[e("li",[t._v("scheme 参数配置：将数据请求信息编码后放到 webview scheme "),e("strong",[t._v("指定参数")]),t._v("中")]),t._v(" "),e("li",[t._v("json 文件配置：数据请求信息采用 JSON 维护，文件地址可以基于 scheme 参数配置，也可以约定固定地址，比如 "),e("code",[t._v("https://页面路径/prefetch.json")])]),t._v(" "),e("li",[t._v("worker 运行时方案：前端编写 JS 函数并单独打包文件，客户端额外启动轻量级 JS 引擎（比如 "),e("a",{attrs:{href:"https://github.com/eclipsesource/tabris-js",target:"_blank",rel:"noopener noreferrer"}},[t._v("tabris"),e("OutboundLink")],1),t._v("(j2v8)、"),e("a",{attrs:{href:"https://github.com/taoweiji/quickjs-android",target:"_blank",rel:"noopener noreferrer"}},[t._v("quickjs"),e("OutboundLink")],1),t._v("）运行该文件。文件地址可以基于配置也可以基于约定。")])]),t._v(" "),e("p",[t._v("方案对比如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:r(760),alt:"Alt text"}})]),t._v(" "),e("blockquote",[e("p",[t._v("PS：大多数情况下，使用 json 方案即可，成本低，收益高")])]),t._v(" "),e("h2",{attrs:{id:"_7️⃣-数据缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣-数据缓存"}},[t._v("#")]),t._v(" 7️⃣ 数据缓存")]),t._v(" "),e("p",[t._v("这个应该很好理解，将页面数据存入缓存；下次进入页面，优先使用缓存数据，同时发起请求以待后续页面更新。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(761),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("需要注意的是，不是所有数据都适合缓存。")]),t._v(" "),e("p",[t._v("对于敏感数据、可能对用户造成较大误解的，不建议缓存，比如积分、金币、红包、金额等与钱有关的数据。")]),t._v(" "),e("p",[t._v("其他相对次要的数据，可以使用缓存，比如收藏记录、粉丝数数据等。")]),t._v(" "),e("blockquote",[e("p",[t._v("是否缓存依业务而定，没有严格的划分标准。")])]),t._v(" "),e("p",[t._v("此外，数据缓存还应该"),e("strong",[t._v("设定缓存时效")]),t._v("，避免数据差异过大。建议缓存一小时，具体可以根据业务决定。")]),t._v(" "),e("h1",{attrs:{id:"五、绘制渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、绘制渲染"}},[t._v("#")]),t._v(" 五、绘制渲染")]),t._v(" "),e("p",[t._v("获取到数据后，最后一步就是绘制渲染了，对应的是 "),e("a",{attrs:{href:"https://web.dev/lcp/",target:"_blank",rel:"noopener noreferrer"}},[t._v("LCP"),e("OutboundLink")],1),t._v(" 这个数据指标。")]),t._v(" "),e("blockquote",[e("p",[t._v("严格来说，前面的资源加载和代码执行阶段也有页面渲染行为，但更多以页面骨架展现为主，对应 FP、FCP、FMP 等数据指标。")])]),t._v(" "),e("p",[t._v("要对这个阶段进行优化，业界常见的方案是预渲染，即在上一个页面的空闲状态，提前渲染页面。")]),t._v(" "),e("p",[t._v("关于预渲染的实现，主要分为两种：")]),t._v(" "),e("ul",[e("li",[t._v("Webview 完全预渲染：额外启动 Webview 容器并完整地加载页面。对性能影响较大，较少使用。")]),t._v(" "),e("li",[t._v("NSR（Native Side Render）：利用客户端原生做 SSR。核心思路是利用客户端启动一个 JS 引擎，执行数据请求 + HTML 文档输出，并将结果缓存。在后续的页面加载过程中，直接渲染 HTML 文档，并做 hydrate （水合）处理。")])]),t._v(" "),e("p",[t._v("NSR 方案相比 Webview 预加载方案更轻量，对系统内存影响较小。本节着重讲第二种 -- NSR。")]),t._v(" "),e("h2",{attrs:{id:"_8️⃣-预渲染-nsr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8️⃣-预渲染-nsr"}},[t._v("#")]),t._v(" 8️⃣ 预渲染 NSR")]),t._v(" "),e("blockquote",[e("p",[t._v("GMTC 2019 全球大前端技术上 UC 团队提到了该方案，详见 "),e("a",{attrs:{href:"https://www.infoq.cn/article/9ukos4xh_6wl4fh1fogl",target:"_blank",rel:"noopener noreferrer"}},[t._v("0.3s完成渲染！UC信息流正文“闪开”优化实践_GMTC_庞锦贵_InfoQ精选文章"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("在上一个页面的空闲状态，客户端进行 NSR 处理，提前请求数据、输出 HTML 文档并缓存。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(762),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("后续加载页面，直接渲染内存中的 HTML 文档，并做 hydrate （水合）处理。")]),t._v(" "),e("p",[t._v("使用该方案后，平均能够提升"),e("strong",[t._v("数百ms")]),t._v("，对 FCP 数据指标的收益较大。同时相比 SSR 方案，对服务端的压力较小。")]),t._v(" "),e("p",[t._v("然而，要实施 NSR 还需关注这 5 个问题：")]),t._v(" "),e("ul",[e("li",[t._v("能力限制：由于跑在 JS 引擎上，会缺失 window/document 等运行时变量，因此需要做 mock 处理，同 SSR。此外，还需关注外部 npm 包的表现，避免直出报错导致白屏。")]),t._v(" "),e("li",[t._v("转化率问题：预渲染需要在前置页面执行，会带来更高的服务端接口负载。如果前置页面到目标页面转化率只有10%，那么请求数量会放大10倍（比如原先只有 10 次用户请求，结果请求了100 次），造成带宽成本浪费和服务端压力。")]),t._v(" "),e("li",[t._v("强依赖客户端和前置页面：需要改造前置页面，通过 jsb 去告知客户端做预渲染。")]),t._v(" "),e("li",[t._v("数据时效性问题：由于缓存机制，首屏页面不是最新数据。若页面对时效性要求较高，则不适合使用。")]),t._v(" "),e("li",[t._v("访问间隔问题：若前置页面很快就进入目标页面，则不推荐使用，会导致 NSR 命中率过低")])]),t._v(" "),e("h1",{attrs:{id:"方案总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方案总结"}},[t._v("#")]),t._v(" 方案总结")]),t._v(" "),e("p",[e("img",{attrs:{src:r(763),alt:"Alt text"}})]),t._v(" "),e("p",[t._v("如果还未建设任何客户端优化方案，建议优先考虑"),e("strong",[t._v("容器预建、资源离线化、数据预取")]),t._v("，能够取得不错的效果。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(764),alt:"Alt text"}})]),t._v(" "),e("h1",{attrs:{id:"后话"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后话"}},[t._v("#")]),t._v(" 后话")]),t._v(" "),e("p",[t._v("本文主要是经验之谈，里面的许多方案通常还需要借助公司基建协助支撑。")]),t._v(" "),e("p",[t._v("由于个人水平有限，如果文章中存在错漏或者不理解的地方，欢迎评论指出，共同进步。如果还有什么其他客户端优化方案，也欢迎评论区补充~")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("👋🏻 Respect！欢迎一键三连 ~")]),t._v(" "),e("h1",{attrs:{id:"拓展阅读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拓展阅读"}},[t._v("#")]),t._v(" 拓展阅读")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.cn/post/7043706765879279629",target:"_blank",rel:"noopener noreferrer"}},[t._v("满满的WebView优化干货，让你的H5实现秒开体验。 - 掘金"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.cn/post/7086284339364757517",target:"_blank",rel:"noopener noreferrer"}},[t._v("得物App H5秒开优化实战 - 掘金"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.cn/post/6844903491383590925",target:"_blank",rel:"noopener noreferrer"}},[t._v("腾讯祭出大招 VasSonic，让你的 H5 页面首屏秒开! - 掘金"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/horkychen/article/details/63033913",target:"_blank",rel:"noopener noreferrer"}},[t._v("Web业务性能优化技术总结_业务性能评估_Horky的博客-CSDN博客"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.cn/post/7016883220025180191",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android WebView H5 秒开方案总结 - 掘金"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://tech.meituan.com/2017/06/09/webviewperf.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("WebView性能、体验分析与优化"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.jianshu.com/p/b908acf1d3a0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android WebView性能分析与优化"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.alloyteam.com/2020/06/fast-open-h5/",target:"_blank",rel:"noopener noreferrer"}},[t._v("大型 h5 页面无缝闪开方案 | AlloyTeam"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.alloyteam.com/2019/10/h5-performance-optimize/",target:"_blank",rel:"noopener noreferrer"}},[t._v("h5 秒开方案大全 | AlloyTeam"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.cn/post/7120907970031910942",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android WebView预渲染 - 掘金"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://yuweiguocn.github.io/android-h5/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android H5秒开方案调研—今日头条H5秒开方案详解"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/Tencent/VasSonic",target:"_blank",rel:"noopener noreferrer"}},[t._v("开源方案：VasSonic - 腾讯出品的一个轻量级的高性能的Hybrid框架【不再维护】"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/yale8848/CacheWebView",target:"_blank",rel:"noopener noreferrer"}},[t._v("开源方案：CacheWebView - 通过拦截资源实现自定义缓存静态资源【不再维护】"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=v.exports},755:function(t,e,r){t.exports=r.p+"assets/img/image-21.419a1052.png"},756:function(t,e,r){t.exports=r.p+"assets/img/image-26.b780eb4b.png"},757:function(t,e,r){t.exports=r.p+"assets/img/image-27.1865f33c.png"},758:function(t,e,r){t.exports=r.p+"assets/img/image-28.d7bf3aaf.png"},759:function(t,e,r){t.exports=r.p+"assets/img/image-29.144d16bb.png"},760:function(t,e,r){t.exports=r.p+"assets/img/image-30.be5b6262.png"},761:function(t,e,r){t.exports=r.p+"assets/img/image-31.7bcc86e6.png"},762:function(t,e,r){t.exports=r.p+"assets/img/image-32.85b66772.png"},763:function(t,e,r){t.exports=r.p+"assets/img/image-34.e566d9b1.png"},764:function(t,e,r){t.exports=r.p+"assets/img/image-33.74b85a7e.png"}}]);