(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{643:function(v,_,t){"use strict";t.r(_);var r=t(4),e=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("什么场景")]),v._v(" "),_("p",[v._v("单线程")]),v._v(" "),_("h1",{attrs:{id:"讲个故事"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#讲个故事"}},[v._v("#")]),v._v(" 讲个故事")]),v._v(" "),_("p",[v._v("常态化核酸")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("DOM：每个人")])]),v._v(" "),_("li",[_("p",[v._v("DOM 属性：每个人的特征")])]),v._v(" "),_("li",[_("p",[v._v("移动：走动")])]),v._v(" "),_("li",[_("p",[v._v("新增：出生")])]),v._v(" "),_("li",[_("p",[v._v("移除：死亡")])]),v._v(" "),_("li",[_("p",[v._v("V-DOM：电子信息")])])]),v._v(" "),_("p",[v._v("更改 dom => 上门验核酸")]),v._v(" "),_("p",[v._v("引入 vdom => 查到哪些人")]),v._v(" "),_("p",[v._v("每一帧渲染 => 每一天统计核酸结果")]),v._v(" "),_("p",[v._v("如果核酸查的比较久，可能就会超过一天，即出现卡顿，工作人员也难受")]),v._v(" "),_("p",[v._v("vdom 比对")]),v._v(" "),_("p",[v._v("任务挂起、恢复、终止")]),v._v(" "),_("p",[v._v("做核酸到 9点，\n从上往下")]),v._v(" "),_("h1",{attrs:{id:"react-fiber"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[v._v("#")]),v._v(" React Fiber")]),v._v(" "),_("p",[v._v("递归渲染 vdom，增删改 dom 就行。")]),v._v(" "),_("p",[v._v("setState 会渲染整个 vdom，而一个应用的所有 vdom 可能是很庞大的，计算量就可能很大。")]),v._v(" "),_("p",[v._v("优化的目标是打断计算，分多次进行，但现在递归的渲染是不能打断的，有两个方面的原因导致的：")]),v._v(" "),_("ul",[_("li",[v._v("渲染的时候直接就操作了 dom 了，这时候打断了，那已经更新到 dom 的那部分怎么办？")]),v._v(" "),_("li",[v._v("现在是直接渲染的 vdom，而 vdom 里只有 children 的信息，如果打断了，怎么找到它的父节点呢？")])]),v._v(" "),_("h1",{attrs:{id:"和-concurrent-的关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#和-concurrent-的关系"}},[v._v("#")]),v._v(" 和 concurrent 的关系")]),v._v(" "),_("p",[v._v("修改了 vdom ，一定要立即响应么？")]),v._v(" "),_("p",[v._v("react Fiber 一定会立即响应么？")]),v._v(" "),_("p",[v._v("fiber 必定会响应每一次")])])}),[],!1,null,null,null);_.default=e.exports}}]);